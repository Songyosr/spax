---
title: "Getting Started with spax: A Healthcare Accessibility Case Study"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with spax: A Healthcare Accessibility Case Study}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 4.5,
  dpi = 100
)
```

# Overview

Let‚Äôs assume we both have at least some passing knowledge of the two-step floating catchment area (2sfca) method. Because BAM! here it is, right in your nose:

**Step 1**: Compute the Supply-to-Demand Ratio

$$R_j = \frac{S_j}{\sum_{i \in C_j} P_i \cdot W_d(d_{ij})}$$

Where:

-   $S_j$ : Service capacity at location j ‚Äî think: number of doctors, school seats, or happy-hour cocktails üç∏.

-   $P_i$ : Population demand at location i ‚Äî how many people want the service.

-   $W_d(d_{ij})$ : Distance decay weight between i and j ‚Äî spoiler: closer = better.

-   $C_j$ : Catchment area around j , aka the ‚Äúzone of influence.‚Äù

**Step 2:** Aggregate Accessibility at Each Demand Location

$$A_k = \sum_{j \in C_k} R_j \cdot W_a(d_{kj})$$

Where:

-   $A_k$ : Accessibility score at demand location k ‚Äî the higher, the better access.

-   $R_j$ : Supply-to-demand ratio from Step 1.

-   $W_a(d_{kj})$ : Accessibility-side decay weight between k and j .

And there you have it: the 2sfca approach in all its glory. If you‚Äôre nodding in recognition (or tilting your head in confusion), no worries. Let‚Äôs break it down.

## Why Do We Care?

In a nutshell, (spatial) accessibility is all about the interplay between **demand**, **supply**, and **distance**. **Demand** represents the size or location of people who need services (e.g., population in a given area), while **supply** is where those services exist (e.g., hospitals, schools, or your favorite late-night taco stands). Once you know where both are, you need the distance or travel time that connects (or separates) them. Whether you store these distances in a matrix, compute them from coordinates, or derive them from a travel-time raster, they represent how hard or easy it is for demand to reach supply.

## Enter the `spax` Package

The `spax` (short for ‚Äúspatial access‚Äù) package offers tools to analyze spatial accessibility to services, with a particular focus on healthcare. The current version leans heavily on raster-based algorithms. This is a big deal if your data or your analysis workflow is raster-focused‚Äîfrom population surfaces to travel-time rasters. (or at least, you can consider migrating to our side). Some key features of spax include:

-   Efficient raster-based spatial accessibility analysis for big dataset (unproven)
-   Algorithmic simplicity and modular design with composable functions for custom workflows
-   Flexible distance decay modeling with built-in and custom functions
-   Support probabilistic demand modeling and Monte Carlo simulation

## Real-World Application: Healthcare Accessibility in Lower Southen Thailand

To illustrate how `spax` can be applied in practice, we'll walk through a real-world scenario: evaluating healthcare accessibility in Thailand's Health Region 12. We'll cover the following steps:

1.  Preparing data on healthcare demand (population) and supply (health facilities)

2.  Computing travel times between demand and supply locations

3.  Conducting accessibility analysis using functions like `compute_access()` and `spax_e2sfca()`

Along the way, we'll see how `spax` makes it easy to incorporate different distance decay functions, handle multi-layered raster data, and generate insightful accessibility maps.

Ready to dive in? Awesome‚Äîlet's go!

# Getting Start

First, let's load the required package

```{r setup}
library(spax) # For accessibility analysis
library(terra) # For raster operations
library(sf) # For vector data handling
library(tidyverse) # For data manipulation + plotting
library(osrm) # For routing services
```

## Data Overview

The package includes several integrated datasets focused on healthcare accessibility of children under 5 in Thailand's Health Region 12:

1.  **Demand:** Under-5 Population Density

```{r}
# Load the datasets (already lazy-loaded in the package)
# Under-5 population density - change from raster to terra::spatRaster
(pop <- rast(u5pd))

# Region boundary
print(bound0)
```

```{r}
# Plot
plot(pop, main = "Under-5 Population Density")
plot(vect(bound0), add = TRUE) # change to SpatVector
```

2.  **Supply:** Location and Capacity of Healthcare Facilities

```{r}
# Healthcare facilities
head(hc12_hos)

# Primary healthcare facilities - not used in this example
head(hc12_phc)
```

```{r}
# Plot basic facility distribution
ggplot() +
  geom_sf(data = bound0, fill = "grey90") +
  geom_sf(data = hc12_hos, aes(color = hoslvl, size = s_doc)) +
  theme_minimal() +
  labs(
    title = "Hospital Distribution in Region 12",
    color = "Hospital Level",
    size = "Number of Doctors"
  ) +
  theme_classic()
```

3.  **Distance:** Travel Time Isochrones to Healthcare Facilities

One way to account for the spatial separation between demand and supply locations is to use travel time isochrones, which represent areas reachable within a given time threshold. This package did not provide a function to generate isochrones, but we can use the ([`osrm`](https://github.com/riatelab/osrm){.uri}) package to calculate travel times between demand and supply locations.

```{r warning=FALSE}
# Example: Calculate isochrones for the first hospital
# Since the dataset I've prepared is in a planar projection, we need to transform it to WGS84 (EPSG:4326) for routing services

(example_hos1 <- hc12_hos[1, ] |> # Select the first hospital
  st_transform(4326) |> # Transform to WGS84 (geodesic projection)
  st_coordinates() |> # Extract coordinates
  as.numeric()) # Convert to numeric

# Calculate isochrones
example_isochrone <- osrm::osrmIsochrone(
  loc = example_hos1, # Example coordinates
  breaks = c(15, 30, 45, 60), # 15-minute intervals
  res = 30 
)

# change crs back
(example_isochrone <- st_transform(example_isochrone, st_crs(bound0)))
par(mfrow = c(1, 2))
plot(example_isochrone[, "isomax"], main = "Travel Time Isochrone for Hospital C1")
plot(example_isochrone[3, "isomax"], main = "Travel Time Isochrone ring for Hospital C1 (45 mins)")
```

As you can see, osrmIsochrone calculates the area reachable within each time threshold for the first hospital (C1) in 15-minute intervals up to 60 minutes as distinct ring-shaped vectors. If you take on a vector-based approach, you can use functions like `st_contain()` to determine the population within each isochrone ring. But in our raster-centric package, we'll rasterize these isochrones for further analysis.

```{r}
# Create a iso_mean column, and id
(example_isochrone <- example_isochrone |>
  mutate(
    iso_mean = (isomin + isomax) / 2,
    location_id = hc12_hos[1, ]$id
  )) # actually dont need it here
# Convert isochrones to raster format
example_raster <- fasterize::fasterize(
  example_isochrone,
  u5pd, # Use the population raster as a template
  field = "iso_mean", # Fill the raster with the isomax values
  background = NA,
  fun = "sum",
  by = "location_id"
) |>
  rast() |>
  crop(vect(bound0), mask = TRUE)

```


```{r}
# Plot
plot(example_raster, main = "Travel Time Isochrone for Hospital C1")
plot(vect(bound0), add = TRUE)
plot(vect(hc12_hos[1, ]), add = TRUE, col = "red", pch = 16)
```

To analyze all hospitals, we can iterate through each facility and compute their isochrones. By default, the osrmIsochrone function uses the OSRM demo server to perform these calculations. However, relying on the demo server is not recommended for large datasets or repeated analyses due to usage limits and ethical considerations. Instead, it‚Äôs advisable to [set up your own OSRM server](https://github.com/Project-OSRM/osrm-backend). This vignette does not cover the server setup process.

```{r, eval=FALSE}
# Example of looping over all hospitals to calculate isochrones
# Note: This code is for illustration only and may not run due to API limitations
# Initialize a list to store isochrones
isochrones <- list(rep(NA, nrow(hc12_hos)))

# Extract coordinates
hos_coords <- hc12_hos |>
  st_transform(4326) |> # only if the data is in planar projection
  st_coordinates()

# Loop over each hospital - lapply
isochrones <- lapply(1:nrow(hc12_hos), function(i) {
  # Calculate isochrone
  osrm::osrmIsochrone(
    loc = hos_coords[i, ],
    breaks = c(15, 30, 45, 60),
    res = 30
  )
}) 

# Then proceed to rastarization ...
```

Luckily, the package includes pre-computed isochrones for each hospital in the region (both in a vector and a raster format). 
```{r}
# Vector format
head(hos_iscvec)

# Raster format
distance_raster <- rast(hos_iscr)
plot(distance_raster[[1]], main = "Distance raster for Hospital C1")
plot(vect(bound0), add = TRUE)
```

## Basic Accessibility Analysis

Let's start with a basic accessibility analysis using the Enhanced Two-Step Floating Catchment Area (E2SFCA) method

```{r}
weights <- calc_decay(
  distance_raster, # Travel time raster
  method = "gaussian",
  sigma = 30 # 30-minute standard deviation
)
```

```{r}
u5_access <- compute_access(
  demand = pop,
  supply = hc12_hos$bed,
  demand_weights = weights,
  access_weights = weights
  #id_col = "location_id",
  #supply_cols = c("s_doc", "s_nurse") # Analyze only doctors
) |> scale() # Normalize the results

plot(u5_access, main = "Doctor Accessibility")
```

