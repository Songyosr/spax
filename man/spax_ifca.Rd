% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/03-iterative_chain.R
\name{spax_ifca}
\alias{spax_ifca}
\title{Iterative Floating Catchment Area (iFCA) Analysis}
\usage{
spax_ifca(
  distance_raster,
  demand,
  supply,
  decay_params = list(method = "gaussian", sigma = 30),
  lambda = 0.5,
  max_iter = 100,
  tolerance = 1e-06,
  window_size = 5,
  convergence_type = c("utilization", "ratio"),
  snap = FALSE,
  debug = FALSE
)
}
\arguments{
\item{distance_raster}{A multi-layer SpatRaster where each layer represents distances
to one facility. All layers must share the same extent and resolution.}

\item{demand}{SpatRaster of demand distribution. Can be either:
- Single layer for static demand
- Multiple layers (matching max_iter) for dynamic demand}

\item{supply}{Numeric vector of facility capacities. Length must match number
of layers in distance_raster.}

\item{decay_params}{List of parameters for decay function:
\itemize{
  \item method: "gaussian", "exponential", "power", or custom function
  \item sigma: decay parameter controlling spatial interaction strength
  \item Additional parameters passed to custom decay functions
}}

\item{lambda}{Learning rate between 0 and 1 controlling convergence speed.
Lower values provide more stability but slower convergence.
Default: 0.5}

\item{max_iter}{Maximum number of iterations to attempt. For multi-layer demand,
this must match the number of demand layers. Default: 100}

\item{tolerance}{Convergence tolerance threshold. Iteration stops when the rolling
average of differences falls below this value. Default: 1e-6}

\item{window_size}{Size of rolling window for convergence checking. Default: 5}

\item{convergence_type}{Character string specifying convergence metric, one of:
"utilization" (default) or "ratio"}

\item{snap}{Logical; if TRUE enables fast computation mode returning only
utilization vector. Default: FALSE}

\item{debug}{Logical; if TRUE provides detailed convergence information.
Default: FALSE}
}
\value{
If snap = TRUE:
  Numeric vector of predicted utilization for all facilities

If snap = FALSE:
  A list containing:
  \describe{
    \item{utilization}{Numeric vector of predicted facility utilization}
    \item{ratios}{Numeric vector of final supply-demand ratios}
    \item{attractiveness}{Numeric vector of final facility attractiveness values}
    \item{accessibility}{SpatRaster of accessibility scores}
    \item{convergence}{List with convergence details:
      \itemize{
        \item iterations: Number of iterations run
        \item converged: Logical indicating if convergence achieved
        \item type: Convergence check method used
        \item final_average: Final rolling average of differences
        \item window_size: Size of rolling window used
      }
    }
    \item{history}{Array of historical state values if converged, NULL otherwise}
    \item{parameters}{List of parameter values used in computation}
  }
}
\description{
Computes spatial accessibility scores using an iterative floating catchment area method
that combines Huff-model based choice probabilities with distance decay effects. This
enhanced version supports time-series demand patterns and customizable decay functions.

The iFCA method extends traditional FCA approaches by:
\itemize{
  \item Supporting dynamic demand patterns through multi-layer inputs
  \item Incorporating flexible distance decay specifications
  \item Iteratively balancing supply and demand
  \item Using a learning rate to control convergence
}
}
\examples{
\dontrun{
# Basic usage with static demand
result <- spax_ifca(
  distance_raster = dist_rast,
  demand = pop_rast,
  supply = facility_capacity,
  decay_params = list(
    method = "gaussian",
    sigma = 30
  )
)

# Using custom decay function
custom_decay <- function(distance, sigma = 30, threshold = 60) {
  weights <- exp(-distance^2 / (2 * sigma^2))
  weights[distance > threshold] <- 0
  return(weights)
}

result <- spax_ifca(
  distance_raster = dist_rast,
  demand = pop_rast,
  supply = facility_capacity,
  decay_params = list(
    method = custom_decay,
    sigma = 30,
    threshold = 60
  )
)

# With time-series demand (must match max_iter)
result <- spax_ifca(
  distance_raster = dist_rast,
  demand = demand_series, # Multi-layer demand
  supply = facility_capacity,
  max_iter = nlyr(demand_series),
  decay_params = list(method = "gaussian", sigma = 30)
)
}

}
\seealso{
\code{\link{calc_decay}} for available decay functions
}
