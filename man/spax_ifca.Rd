% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iterative_chain.R
\name{spax_ifca}
\alias{spax_ifca}
\title{Iterative Floating Catchment Area (iFCA) Analysis}
\usage{
spax_ifca(
  distance_raster,
  demand,
  supply,
  sigma,
  lambda = 0.5,
  max_iter = 100,
  tolerance = 1e-06,
  window_size = 5,
  convergence_type = c("utilization", "ratio"),
  snap = FALSE,
  debug = FALSE
)
}
\arguments{
\item{distance_raster}{A multi-layer SpatRaster where each layer represents distances
to one facility. All layers must share the same extent and resolution.}

\item{demand}{SpatRaster of demand distribution (e.g., population density).
Must have same extent and resolution as distance_raster.}

\item{supply}{Numeric vector of facility capacities. Length must match number
of layers in distance_raster. Zero values are allowed.}

\item{sigma}{Distance decay parameter controlling spatial interaction strength.
Larger values indicate weaker distance decay effect.}

\item{lambda}{Learning rate between 0 and 1 controlling convergence speed.
Lower values provide more stability but slower convergence.
Default: 0.5}

\item{max_iter}{Maximum number of iterations to attempt. Default: 100}

\item{tolerance}{Convergence tolerance threshold. Iteration stops when the rolling
average of differences falls below this value. Default: 1e-6}

\item{window_size}{Size of rolling window for convergence checking. Default: 5}

\item{convergence_type}{Character string specifying convergence metric:
"utilization" (default) or "ratio"}

\item{snap}{Logical; if TRUE enables fast computation mode returning only
utilization vector. Default: FALSE}

\item{debug}{Logical; if TRUE provides detailed convergence information.
Default: FALSE}
}
\value{
If snap = TRUE:
  Numeric vector of predicted utilization for all facilities

If snap = FALSE:
  List containing:
  \describe{
    \item{utilization}{Numeric vector of predicted facility utilization}
    \item{ratios}{Numeric vector of final supply-demand ratios}
    \item{attractiveness}{Numeric vector of final facility attractiveness values}
    \item{accessibility}{SpatRaster of accessibility scores}
    \item{convergence}{List with convergence details:
      \itemize{
        \item iterations: Number of iterations run
        \item converged: Logical indicating if convergence achieved
        \item type: Convergence check method used
        \item final_average: Final rolling average of differences
        \item window_size: Size of rolling window used
      }
    }
    \item{history}{Array of historical state values if converged, NULL otherwise}
    \item{parameters}{List of parameter values used in computation}
  }
}
\description{
Computes spatial accessibility scores using an iterative floating catchment area method
that combines Huff-model based choice probabilities with distance decay effects. The method
iteratively adjusts facility attractiveness based on supply-demand ratios until convergence.

The iFCA method extends traditional FCA approaches by:
\itemize{
  \item Incorporating choice behavior through a Huff-model framework
  \item Iteratively balancing supply and demand
  \item Using a learning rate to control convergence
  \item Supporting both utilization and ratio-based convergence checks
}
}
\examples{
\dontrun{
# Basic usage
result <- spax_ifca(
  distance_raster = dist_rast,
  demand = pop_rast,
  supply = facility_capacity,
  sigma = 30
)

# Fast computation mode
util <- spax_ifca(
  distance_raster = dist_rast,
  demand = pop_rast,
  supply = facility_capacity,
  sigma = 30,
  snap = TRUE
)

# With modified convergence settings
result <- spax_ifca(
  distance_raster = dist_rast,
  demand = pop_rast,
  supply = facility_capacity,
  sigma = 30,
  lambda = 0.3,            # Slower but more stable convergence
  convergence_type = "ratio",
  tolerance = 1e-8,        # Stricter convergence
  window_size = 10         # Longer rolling window
)

# Plot accessibility surface
if (!is.null(result$accessibility)) {
  plot(result$accessibility)
}

# Check convergence history
if (!is.null(result$history)) {
  plot(1:result$convergence$iterations,
       result$history[,,1],  # Plot utilization history
       type = "l",
       xlab = "Iteration",
       ylab = "Utilization")
}
}

}
\references{
The iFCA method builds on:
\itemize{
  \item Huff's model of retail gravitation
  \item Two-Step Floating Catchment Area (2SFCA) method
  \item Enhanced 2SFCA (E2SFCA) with variable catchment sizes
}
}
\seealso{
\code{\link{compute_weights}} for decay function options
}
