% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/access_chain.R
\name{run_access_chain}
\alias{run_access_chain}
\title{Iterative Spatial Accessibility Chain Algorithm}
\usage{
run_access_chain(
  distance_raster,
  demand,
  supply,
  sigma,
  lambda = 0.5,
  method = "gaussian",
  decay_params = list(),
  convergence_type = c("utilization", "ratio"),
  max_iter = 100,
  tolerance = 1e-06,
  track_history = TRUE,
  snap = FALSE,
  internal_snap = TRUE,
  debug = FALSE
)
}
\arguments{
\item{distance_raster}{Multi-layer SpatRaster where each layer represents distances
to one facility. All layers must share the same extent and resolution.}

\item{demand}{SpatRaster of demand distribution (e.g., population density).
Must have same extent and resolution as distance_raster.}

\item{supply}{Numeric vector of facility capacities. Length must match number
of layers in distance_raster.}

\item{sigma}{Distance decay parameter controlling spatial interaction strength.
Interpretation depends on chosen decay function.}

\item{lambda}{Learning rate between 0 and 1 controlling convergence speed.
Lower values provide more stability but slower convergence.}

\item{method}{Either a string specifying the decay function ("gaussian",
"exponential", "power", "binary") or a custom decay function that takes
parameters specified in decay_params.}

\item{decay_params}{List of additional parameters passed to custom decay functions.
Ignored when using built-in decay methods.}

\item{convergence_type}{Character indicating convergence check method:
"utilization" (default) or "ratio"}

\item{max_iter}{Maximum number of iterations (default 100)}

\item{tolerance}{Convergence tolerance (default 1e-6)}

\item{snap}{Logical; if TRUE skips input validation for faster execution}

\item{internal_snap}{Logical; if TRUE passes snap=TRUE to internal functions}

\item{debug}{Logical; if TRUE provides detailed convergence information}
}
\value{
A list containing:
  \item{utilization}{Matrix [iterations x facilities] of utilization history}
  \item{attractiveness}{Vector of final attractiveness values for each facility}
  \item{ratios}{Vector of final supply-demand ratios}
  \item{accessibility}{SpatRaster of final accessibility surface}
  \item{convergence}{List with convergence details:
    \itemize{
      \item iterations: Number of iterations run
      \item converged: Logical indicating if convergence was achieved
      \item differences: Matrix of differences across iterations
      \item ratios: Matrix of supply-demand ratios across iterations
      \item type: Convergence check method used
    }
  }
}
\description{
Implements an iterative spatial accessibility model that finds equilibrium between
supply and demand through a chain of facility choices. The model combines Huff-based
choice probabilities with distance decay to simulate how demand is distributed across
facilities, using a learning rate to dampen oscillations and achieve stable convergence.

The algorithm follows these steps in each iteration:
1. Compute choice probabilities based on facility attractiveness
2. Calculate expected utilization at each facility
3. Update supply-demand ratios
4. Adjust facility attractiveness using learning rate
5. Check for convergence

The function implements two convergence criteria:
- "utilization": Checks for stability in facility utilization
- "ratio": Checks for stability in supply-demand ratios
}
\examples{
\dontrun{
# Basic usage with Gaussian decay
result <- run_access_chain(
  distance_raster = dist_rast,
  demand = pop_rast,
  supply = facility_capacity,
  sigma = 30,
  method = "gaussian"
)

# Using custom decay function
custom_decay <- function(distance, sigma, k) {
  1 / (1 + (distance/(sigma*k))^2)
}
result <- run_access_chain(
  distance_raster = dist_rast,
  demand = pop_rast,
  supply = facility_capacity,
  sigma = 30,
  method = custom_decay,
  decay_params = list(k = 0.5)
)
}

}
