[{"path":"https://songyosr.github.io/spax/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Songyos Rajborirug Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-101-intro.html","id":"getting-started-with-spax","dir":"Articles","previous_headings":"","what":"Getting Started with spax","title":"1. Getting Started with spax: A Healthcare Accessibility Case Study","text":"Ever wondered measure whether people can actually reach services need? ’s spatial accessibility analysis comes . many ways approach challenge, spax package offers fresh perspective raster-based tools.","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-101-intro.html","id":"what-makes-spax-different","dir":"Articles","previous_headings":"Getting Started with spax","what":"What Makes spax Different?","title":"1. Getting Started with spax: A Healthcare Accessibility Case Study","text":"accessibility tools work points distance matrices - think dots map connected lines. spax takes different approach: Raster-First: expense memory (lol), spax Built around continuous surfaces rather discrete points, making perfect working high-resolution population data complex service areas Modular Design: Chain together functions build custom workflows - like LEGO bricks spatial analysis Performance-Focused: Optimized large spatial datasets, sometimes need analyze entire region Uncertainty-Aware: real world isn’t deterministic, spax includes tools Monte Carlo simulation sensitivity analysis","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-101-intro.html","id":"the-building-blocks","dir":"Articles","previous_headings":"Getting Started with spax","what":"The Building Blocks","title":"1. Getting Started with spax: A Healthcare Accessibility Case Study","text":"Every spatial accessibility analysis needs three key ingredients: Demand refers size location population requiring services. can represented population density map aggregated values administrative unit centroids (e.g., number elderly residents neighborhood). Supply represents capacity location service providers. number doctors hospital, number seats available schools, even stock happy-hour cocktails favorite bar 🍸. Distance: connects dots demand supply. defines effort needed bridge two, whether travel time physical separation. Distances can stored matrices, calculated coordinates, derived travel-time rasters, offering insights accessibility supply need. Let’s see look practice using example dataset Thailand’s Health Region 12.","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-101-intro.html","id":"working-with-example-data","dir":"Articles","previous_headings":"Getting Started with spax","what":"Working with Example Data","title":"1. Getting Started with spax: A Healthcare Accessibility Case Study","text":"📝 Data Note: example dataset comes Thailand’s Health Region 12, combining hospital records, Meta’s population density maps, OSRM-computed travel times. package includes several integrated datasets (already lazy-loaded) showcase healthcare accessibility analysis action. Let’s load required packages first:","code":"library(spax) # For accessibility analysis library(terra) # For raster operations library(raster) library(sf) # For vector data handling library(tidyverse) # For data manipulation + plotting #> Error in get(paste0(generic, \".\", class), envir = get_method_env()) :  #>   object 'type_sum.accel' not found"},{"path":"https://songyosr.github.io/spax/articles/spax-101-intro.html","id":"understanding-demand","dir":"Articles","previous_headings":"Getting Started with spax > Working with Example Data","what":"1. Understanding Demand","title":"1. Getting Started with spax: A Healthcare Accessibility Case Study","text":"example uses -5 population density data aggregated Meta’s High Resolution Population Density Maps: Let’s visualize region boundary:  raster shows us children 5 years old located across region, brighter colors indicating higher density areas.","code":"# Load the population density data pop <- rast(u5pd) # Convert from raster to terra::SpatRaster  # Quick view of the data print(pop) #> class       : SpatRaster  #> dimensions  : 509, 647, 1  (nrow, ncol, nlyr) #> resolution  : 520.4038, 520.4038  (x, y) #> extent      : 505646.5, 842347.8, 620843.7, 885729.2  (xmin, xmax, ymin, ymax) #> coord. ref. : +proj=utm +zone=47 +datum=WGS84 +units=m +no_defs  #> source(s)   : memory #> name        : tha_children_under_five_2020  #> min value   :                      0.00000  #> max value   :                     83.07421 res(pop) # each cell is ~520m x 520m #> [1] 520.4038 520.4038 # Plot population density plot(pop, main = \"Under-5 Population Density\") plot(vect(bound0), add = TRUE) # Add region boundary"},{"path":"https://songyosr.github.io/spax/articles/spax-101-intro.html","id":"exploring-supply","dir":"Articles","previous_headings":"Getting Started with spax > Working with Example Data","what":"2. Exploring Supply","title":"1. Getting Started with spax: A Healthcare Accessibility Case Study","text":"healthcare supply, detailed information hospitals (hc12_hos)","code":"# Look at hospital data head(hc12_hos) #> Simple feature collection with 6 features and 10 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 659422 ymin: 744135 xmax: 715990.7 ymax: 824148 #> Projected CRS: WGS 84 / UTM zone 47N #> # A tibble: 6 × 11 #>   id    hoslvl       bed s_doc s_dent s_nurse  s_hv d_pop_moph d_pop_moph_60 #>   <chr> <fct>      <dbl> <int>  <int>   <int> <int>      <dbl>         <dbl> #> 1 c172  3-Regional   591   522     44     973     0          0             0 #> 2 c173  2-General    508   321     18     706     0          0             0 #> 3 c174  2-General     30    67      6      63     0          0             0 #> 4 c175  2-General     60    81      9     103     0          0             0 #> 5 c176  2-General     90   175     12     180     0          0             0 #> 6 c177  2-General     60    77      9     103     0          0             0 #> # ℹ 2 more variables: d_pop_moph_05 <dbl>, geometry <POINT [m]>  # Visualize hospital distribution and capacity ggplot() +   geom_sf(data = bound0, fill = \"grey95\", color = \"grey70\") +   geom_sf(data = hc12_hos, aes(color = hoslvl, size = s_doc)) +   scale_size_continuous(name = \"Number of Doctors\") +   scale_color_viridis_d(name = \"Hospital Level\") +   theme_minimal() +   labs(     title = \"Hospital Distribution in Region 12\",     subtitle = \"Size indicates number of doctors\"   )"},{"path":"https://songyosr.github.io/spax/articles/spax-101-intro.html","id":"distance-and-travel-time","dir":"Articles","previous_headings":"Getting Started with spax > Working with Example Data","what":"3. Distance and Travel Time","title":"1. Getting Started with spax: A Healthcare Accessibility Case Study","text":"package includes pre-computed travel time data showing long takes reach facility:","code":"# Load the travel time data distance_raster <- rast(hos_iscr) # Convert to terra::SpatRaster distance_raster #> class       : SpatRaster  #> dimensions  : 509, 647, 77  (nrow, ncol, nlyr) #> resolution  : 520.4038, 520.4038  (x, y) #> extent      : 505646.5, 842347.8, 620843.7, 885729.2  (xmin, xmax, ymin, ymax) #> coord. ref. : +proj=utm +zone=47 +datum=WGS84 +units=m +no_defs  #> source(s)   : memory #> names       :  c172,  c173,  c174,  c175,  c176,  c177, ...  #> min values  :   6.0,   3.0,   3.5,   4.0,   4.0,  11.0, ...  #> max values  : 172.5, 172.5, 172.5, 172.5, 172.5, 172.5, ... # Each layer represents travel time to a different facility   # Look at travel time to one facility plot(distance_raster[[1]],   main = \"Travel Time to Hospital C1 (minutes)\" ) plot(vect(bound0), add = TRUE) plot(hc12_hos[1, ], add = TRUE, pch = 16, col = \"red\") #> Warning in plot.sf(hc12_hos[1, ], add = TRUE, pch = 16, col = \"red\"): ignoring #> all but the first attribute"},{"path":"https://songyosr.github.io/spax/articles/spax-101-intro.html","id":"quick-start-basic-accessibility-analysis","dir":"Articles","previous_headings":"Getting Started with spax","what":"Quick Start: Basic Accessibility Analysis","title":"1. Getting Started with spax: A Healthcare Accessibility Case Study","text":"Now understand data, let’s put together basic accessibility analysis. ’ll use Enhanced Two-Step Floating Catchment Area (E2SFCA) method analyze access doctors:  ’s ! ’ve calculated accessibility scores doctors nurses across region lighter colors indicating better access.","code":"# Calculate accessibility scores accessibility <- spax_e2sfca(   demand = pop, # Population density   supply = hc12_hos |> st_drop_geometry(), # Hospital capacity   distance = distance_raster, # Travel times   decay_params = list( # How access decays with distance     method = \"gaussian\",     sigma = 30 # 30-minute characteristic distance   ),   demand_normalize = \"standard\", # Prevent demand inflation   id_col = \"id\",   supply_cols = c(\"s_doc\", \"s_nurse\") # Analyze doctors and nurses ) # Visualize the results plot(accessibility,   main = c(\"Access to Doctors\", \"Access to Nurses\") ) plot(vect(bound0), add = TRUE)"},{"path":"https://songyosr.github.io/spax/articles/spax-101-intro.html","id":"whats-next","dir":"Articles","previous_headings":"Getting Started with spax","what":"What’s Next?","title":"1. Getting Started with spax: A Healthcare Accessibility Case Study","text":"introduction just scratches surface spax can . advanced topics, check : Data Preparation Guide Dissecting spax: Understanding package’s inner workings Understanding Raster Trade-offs","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"data-preparation-for-accessibility-analysis","dir":"Articles","previous_headings":"","what":"Data Preparation for Accessibility Analysis","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"“Give six hours chop tree, spend first four sharpening axe.” — Abraham Lincoln(?)","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"overview","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis","what":"Overview","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"Spatial accessibility analysis requires three key components: Demand: Population service need distribution Supply: Service locations capacities Distance: Travel time distance demand supply guide walks preparing component use spax.","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"dealing-with-demand","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis","what":"Dealing with Demand","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"preparing demand data spatial accessibility analysis, several approaches available, assumptions trade-offs. Let’s explore methods using simple example disease cases province. vector-based approach, typically represent area polygon attribute number cases. often results choropleth maps, like :  sometimes misleading since traditional spatial analysis, often allocate demand centroid area:  centroid approach works vector-centric analysis, spax, need think terms continuous surfaces. Let’s explore different ways convert data","code":"set.seed(42) # For reproducibility  # Example district-level case data case_data <- tibble(   ADM1_PCODE = bound1$ADM1_PCODE,   cases = round(rnorm(nrow(bound1), 1000, 200)) # Simulated disease cases )  # Join with spatial data case_spatial <- bound1 |>   left_join(case_data, by = \"ADM1_PCODE\") # Plot the case ggplot() +   geom_sf(data = bound1) +   geom_sf(data = case_spatial, aes(fill = cases)) +   labs(title = \"Cases by Province\") +   scale_fill_viridis_b() +   theme_minimal() # Calculate centroids and rasterize centroids <- st_centroid(case_spatial) #> Warning: st_centroid assumes attributes are constant over geometries  # Plot the population data ggplot() +   geom_sf(data = bound1) +   geom_sf(data = centroids, aes(size = cases), col = \"red\") +   labs(title = \"Population Data by Region\") +   theme_minimal()"},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"centroid-based-approach","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis > Dealing with Demand","what":"1. Centroid-Based Approach","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"simplest approach treats demand concentrated area centroids. mirrors traditional vector-based accessibility analyses raster format:  can see, approach creates somewhat odd-looking result - demand concentrated single cells. However, raster can still used accessibility analysis, just like original population density raster. key trade-simplicity spatial accuracy.","code":"# Create template raster - Coarser resolution for example template <- aggregate(rast(u5pd), fact = 10)  # Rasterize centroids centroid_demand <- terra::rasterize(   vect(centroids),   template,   field = \"cases\",   fun = \"sum\" ) plot(centroid_demand, main = \"Centroid-Based Demand\") plot(vect(bound1), add = TRUE)"},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"area-weighted-approach-developing","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis > Dealing with Demand","what":"2. Area-Weighted Approach [developing]","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"sophisticated method distributes cases evenly across province’s area: Let’s see looks:  gives us continuous surface, validate totals still match: differences original rasterized values arise discretization process. results get closer resolution increases, ’s always trade-accuracy computational efficiency.","code":"# 1. Calculate case density case_spatial <- case_spatial |>   mutate(     area_m2 = st_area(case_spatial), # estimate area     case_density = as.numeric(cases / area_m2) # calc density   )  # 2. Rasterize case density case_density_raster <- terra::rasterize(   vect(case_spatial),   template,   field = \"case_density\" )  # 3. Calculate pixel area in square kilometers pixel_area <- terra::res(template)[1] * terra::res(template)[2]  # 4. Convert density to absolute cases per pixel case_raster <- case_density_raster * pixel_area # Plot plot(case_raster, main = \"Area-Weighted Demand\") plot(vect(bound1), add = TRUE) # Extract raster values for each polygon extracted_cases <- terra::extract(   case_raster,   vect(case_spatial),   fun = sum, na.rm = TRUE )  # Compare original vs rasterized totals case_spatial |>   st_drop_geometry() |>   select(ADM1_PCODE, cases) |>   mutate(     raster_cases = extracted_cases[, 2],     difference = abs(cases - raster_cases),     pct_diff = (difference / cases) * 100   ) |>    mutate_if(is.numeric, round, 1) #>   ADM1_PCODE cases raster_cases difference pct_diff #> 1       TH90  1274       1261.4       12.6      1.0 #> 2       TH91   887        867.4       19.6      2.2 #> 3       TH92  1073       1068.1        4.9      0.5 #> 4       TH93  1127       1131.1        4.1      0.4 #> 5       TH94  1081       1085.9        4.9      0.5 #> 6       TH95   979        995.2       16.2      1.7 #> 7       TH96  1302       1286.8       15.2      1.2"},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"informed-distribution-developing","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis > Dealing with Demand","what":"3. Informed Distribution [developing]","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"Even realistic distribution possible using auxiliary data like population density inform cases likely occur within province. section expanded future versions.","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"probabilistic-sampling-developing","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis > Dealing with Demand","what":"4. Probabilistic Sampling [developing]","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"uncertainty analysis, spax provides tools generate multiple potential demand distributions: choice demand preparation method can significantly impact accessibility analysis results. Consider specific context: Data availability (population density data?) Scale analysis (districts large enough distribution matters?) Purpose (point-based analysis sufficient needs?) Computational resources (Can handle higher resolution distributions?)","code":"# This advanced approach is covered in detail in the  # \"Probabilistic Accessibility Analysis\" vignette  ?sample_pmf  # See documentation for details"},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"processing-supply-data","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis","what":"Processing Supply Data","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"Supply data usually straightforward component - typically know exactly facilities capacities. However, locations play crucial role complex task distance calculation follows.. use spax, supply data separated : Spatial locations (distance calculations) Capacity attributes (accessibility computations)","code":"# Basic Supply Structure head(hc12_hos) |>   select(id, hoslvl, s_doc, s_nurse) #> Simple feature collection with 6 features and 4 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 659422 ymin: 744135 xmax: 715990.7 ymax: 824148 #> Projected CRS: WGS 84 / UTM zone 47N #> # A tibble: 6 × 5 #>   id    hoslvl     s_doc s_nurse            geometry #>   <chr> <fct>      <int>   <int>         <POINT [m]> #> 1 c172  3-Regional   522     973 (662036.1 775836.7) #> 2 c173  2-General    321     706   (672852 789753.3) #> 3 c174  2-General     67      63     (659422 824148) #> 4 c175  2-General     81     103     (692195 764766) #> 5 c176  2-General    175     180   (687203.3 744135) #> 6 c177  2-General     77     103 (715990.7 752559.6) # Separate spatial and attribute components supply_attributes <- hc12_hos |>   st_drop_geometry() |>   select(id, s_doc, s_nurse) # Keep only relevant columns  # Visual check of supply distribution ggplot() +   geom_sf(data = bound1, fill = \"grey80\") +   geom_sf(data = hc12_hos, aes(size = s_doc, color = hoslvl)) +   scale_size_continuous(name = \"Number of Doctors\") +   scale_color_viridis_d(name = \"Hospital Level\", end = 0.5) +   theme_minimal() +   labs(     title = \"Healthcare Supply Distribution\",     subtitle = \"Size indicates number of doctors, color shows facility level\"   )"},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"creating-distancetravel-time-surfaces","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis","what":"Creating Distance/Travel Time Surfaces","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"supply locations straightforward, calculating distances supply demand points often complex part data preparation. Although ’s theoretically possible calculate distances either supply demand demand supply (assuming travel times symmetric), practical reasons typically calculate supply points: usually fewer supply points demand points, making computation efficient redistributing accessibility scores back population, need supply-based distances anyway Let’s explore different approaches creating distance surfaces:","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"euclidean-distance","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis > Creating Distance/Travel Time Surfaces","what":"1. Euclidean Distance","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"simplest approach - straight-line distances:  simple, approach ignores real-world travel constraints like roads barriers. ’s useful : Initial exploratory analysis Areas relatively uniform transportation networks Services aren’t strictly road-dependent","code":"# Example for one facility using terra facility_point <- hc12_hos[1, ] template_rast <- rast(u5pd) # Use population raster as template  # Calculate Euclidean distance (in meters since our CRS is projected) euclidean_dist <- terra::distance(   template_rast,   vect(facility_point) ) |> crop(vect(bound0), mask = TRUE) #> |---------|---------|---------|---------|========================================= # Plot the Euclidean distance plot(euclidean_dist / 1000, # Convert to kilometers   main = \"Euclidean Distance (km)\" ) plot(vect(facility_point), add = TRUE, col = \"red\", pch = 16) plot(vect(bound0), add = TRUE)"},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"travel-time-isochrones","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis > Creating Distance/Travel Time Surfaces","what":"2. Travel Time Isochrones","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"realistic approach uses travel time isochrones - areas reachable within specific time thresholds. spax doesn’t generate isochrones directly, can use tools like osrm package:   isochrones show travel time “rings” around facility. take vector-based approach, can use functions like sf::st_contains() determine population within isochrone ring. spax, need convert raster format:  ⚠️ Important Note OSRM: default, osrm::osrmIsochrone()] function uses OSRM’s demo server. fine testing, real analysis : Set OSRM server. vignette cover server setup process. Consider rate limits (demo server allows ~1 request/second) mindful server load ethical usage process facilities, ’d need loop :","code":"# Example: Calculate isochrones for the first hospital # Since our data is in a planar projection, we need to transform it to WGS84 (EPSG:4326) for routing services  example_hos1 <- hc12_hos[1, ] |> # Select the first hospital   st_transform(4326) |> # Transform to WGS84 (geodesic projection)   st_coordinates() |> # Extract coordinates   as.numeric() # Convert to numeric  # Calculate isochrones example_isochrone <- osrmIsochrone(   loc = example_hos1, # Example coordinates   breaks = c(15, 30, 45, 60), # 15-minute intervals   res = 30 )  # Transform back to our working CRS example_isochrone <- st_transform(example_isochrone, st_crs(bound0))  # Plot results par(mfrow = c(1, 2)) plot(example_isochrone[, \"isomax\"], main = \"Travel Time Isochrone for Hospital C1\") plot(example_isochrone[3, \"isomax\"], main = \"Travel Time Isochrone ring for Hospital C1 (45 mins)\") # Prepare isochrones for rasterization example_isochrone <- example_isochrone |>   mutate(     iso_mean = (isomin + isomax) / 2,     location_id = hc12_hos[1, ]$id    )  # Convert to raster format example_raster <- terra::rasterize(   x = example_isochrone,   y = template_rast,   field = \"iso_mean\", # Fill the raster with the isomax values   background = NA,   fun = \"sum\",   by = \"location_id\" ) |>   crop(vect(bound0), mask = TRUE) # Plot plot(example_raster, main = \"Travel Time Isochrone for Hospital C1\") plot(vect(bound0), add = TRUE) plot(vect(hc12_hos[1, ]), add = TRUE, col = \"red\", pch = 16) # Example code (not run due to API limitations)  # Initialize a list to store isochrones isochrones <- list(rep(NA, nrow(hc12_hos)))  # Extract coordinates hos_coords <- hc12_hos |>   st_transform(4326) |> # only if the data is in planar projection   st_coordinates()  # Loop over each hospital - lapply isochrones <- lapply(1:nrow(hc12_hos), function(i) {   # Calculate isochrone   osrmIsochrone(     loc = hos_coords[i, ],     breaks = c(15, 30, 45, 60),     res = 30   ) }) # Then proceed to rastarization ..."},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"service-provider-options","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis > Creating Distance/Travel Time Surfaces","what":"Service Provider Options","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"creating travel time surfaces, several options: OSRM (Open Source Routing Machine) Free open source Can handle multiple travel modes (setup properly) × Requires server setup serious use × Basic routing without traffic Commercial APIs (, Google Maps) Includes real-time traffic accurate travel times × Usage costs × API limits Custom cost surfaces (idea , lol) Can include terrain, land use Full control parameters × Requires GIS expertise × complex validate","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"validating-your-data-essential-checks-before-analysis","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis","what":"Validating Your Data: Essential Checks Before Analysis","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"running accessibility analysis, ’s crucial validate prepared data. ’s systematic approach validation (already implemented package:) :","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"spatial-alignment","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis > Validating Your Data: Essential Checks Before Analysis","what":"1. Spatial Alignment","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"raster inputs must align perfectly - extent, resolution, projection:","code":"# Example: # You might want to create function to summarize raster properties summarize_raster <- function(r, name) {   tibble(     Dataset = name,     Resolution = paste(round(res(r), 2), collapse = \" x \"),     Extent = paste(round(as.vector(ext(r)), 2), collapse = \", \"),     CRS = crs(r, proj = TRUE)   ) }  # Compare properties of key rasters raster_props <- bind_rows(   summarize_raster(rast(u5pd), \"Population\"),   summarize_raster(rast(hos_iscr), \"Travel Time\") )  raster_props #> # A tibble: 2 × 4 #>   Dataset     Resolution    Extent                                     CRS       #>   <chr>       <chr>         <chr>                                      <chr>     #> 1 Population  520.4 x 520.4 505646.53, 842347.77, 620843.72, 885729.24 +proj=ut… #> 2 Travel Time 520.4 x 520.4 505646.53, 842347.77, 620843.72, 885729.24 +proj=ut…  # Visual check for alignment plot(rast(u5pd), main = \"Spatial Alignment Check\") plot(rast(hos_iscr)[[1]], add = TRUE, alpha = 0.5) plot(vect(bound1), add = TRUE)"},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"value-range-validation","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis > Validating Your Data: Essential Checks Before Analysis","what":"2. Value Range Validation","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"Check reasonable values input data:","code":"# Check population density range summary(u5pd) #>         tha_children_under_five_2020 #> Min.                    0.000000e+00 #> 1st Qu.                 1.385807e+00 #> Median                  3.497750e+00 #> 3rd Qu.                 7.571418e+00 #> Max.                    8.307421e+01 #> NA's                    2.781020e+05  # Check a few travel time rasters summary(hos_iscr[[1:10]])  #>             [,1]     [,2]     [,3]     [,4]     [,5]     [,6]     [,7]     [,8] #> Min.         6.0      3.0      3.5      4.0      4.0     11.0      5.0      7.5 #> 1st Qu.     67.5     82.5     97.5     67.5     67.5     67.5     82.5     97.5 #> Median     112.5    112.5    127.5    112.5    112.5    112.5    127.5    127.5 #> 3rd Qu.    142.5    157.5    157.5    142.5    157.5    157.5    157.5    157.5 #> Max.       172.5    172.5    172.5    172.5    172.5    172.5    172.5    172.5 #> NA's    214422.0 215942.0 226281.0 208815.0 214457.0 219237.0 228511.0 228151.0 #>             [,9]    [,10] #> Min.         5.0      4.0 #> 1st Qu.     97.5     67.5 #> Median     127.5    112.5 #> 3rd Qu.    157.5    142.5 #> Max.       172.5    172.5 #> NA's    233929.0 215368.0"},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"missing-value-analysis","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis > Validating Your Data: Essential Checks Before Analysis","what":"3. Missing Value Analysis","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"Understand NA values; note NAs bad:","code":"# Function to analyze NA patterns within boundary # PS. Will be implemented in the package later analyze_nas <- function(r, name, bound = bound0) {   # Create mask from boundary   mask <- terra::rasterize(bound, r)    # Count cells only within boundary   cells_in_boundary <- global(!is.na(mask), \"sum\")$sum   nas_in_boundary <- global(is.na(r) & !is.na(mask), \"sum\")$sum    cat(     sprintf(\"%s:\\n\", name),     sprintf(       \"  NA cells within boundary: %d (%.1f%% of study area)\\n\",       nas_in_boundary,       100 * nas_in_boundary / cells_in_boundary     )   )    # Visualize NA pattern   na_map <- (is.na(r) & !is.na(mask)) |> crop(bound, mask = T)    plot(na_map,     main = paste(name, \"- NAs within Study Area\"),     col = c(\"grey80\", \"red\"),     legend = FALSE   )   plot(vect(bound1), add = TRUE)   legend(\"bottomright\",     legend = c(\"Data present\", \"NA\"),     fill = c(\"grey80\", \"red\"),     bty = \"n\"   ) }  # Check NA patterns in key datasets par(mfrow = c(1, 2)) analyze_nas(rast(u5pd), \"Pop\") #> Pop: #>    NA cells within boundary: 60551 (54.4% of study area) analyze_nas(rast(hos_iscr)[[1]], \"Time from 1st Fac\") #> Time from 1st Fac: #>    NA cells within boundary: 16841 (15.1% of study area)"},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"final-reminders","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis > Validating Your Data: Essential Checks Before Analysis","what":"Final reminders:","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"Resolution Selection Higher resolution ≠ better analysis Consider computational resources Match resolution spatial scale research question Coordinate Reference Systems consistent CRS across datasets Document CRS choices transformations Consider distortion implications Documentation Note data sources dates Document preprocessing steps Record assumptions made Note known limitations","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-102-data-prep.html","id":"next-steps","dir":"Articles","previous_headings":"Data Preparation for Accessibility Analysis","what":"Next Steps","title":"2. Preparing Data for Spatial Accessibility Analysis","text":"data prepared, ’re ready move actual accessibility analysis. can explore following resources information: Dissecting spax: Understanding package’s inner workings Understanding Raster Trade-offs","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"okay-time-for-some-theory","dir":"Articles","previous_headings":"","what":"Okay, Time for Some Theory!","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"’ve avoiding moment two whole vignettes, ’s escaping anymore - need talk theory. Don’t worry though! Like good recipe, spatial accessibility analysis just matter combining simple ingredients right way. Let’s peek hood spax understand: spatial accessibility actually calculated chose certain approaches others theory translates actual code","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"the-recipe-for-spatial-accessibility","dir":"Articles","previous_headings":"Okay, Time for Some Theory!","what":"The Recipe for Spatial Accessibility","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"heart, spatial accessibility tries answer deceptively simple question: “easily can people reach services need?” involves three key ingredients: People need services (demand) Places provide services (supply) effort needed connect (distance/time) Enhanced Two-Step Floating Catchment Area (E2SFCA) method, spax implements, combines ingredients two steps:","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"step-1-service-to-population-ratios","dir":"Articles","previous_headings":"Okay, Time for Some Theory! > The Recipe for Spatial Accessibility","what":"Step 1: Service-to-Population Ratios","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"First, calculate much service capacity available relative potential demand. service location jj: Rj=Sj∑iPiWd(dij) R_j = \\frac{S_j}{\\sum_i P_i W_d(d_{ij})} : SjS_jis service capacity (like number doctors) PiP_i population location ii Wd(dij)W_d(d_{ij}) weight based travel time/distance RjR_j resulting service--population ratio Think like calculating “doctor--patient ratio” hospital, twist – patients weighted far travel.","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"step-2-accessibility-scores","dir":"Articles","previous_headings":"Okay, Time for Some Theory! > The Recipe for Spatial Accessibility","what":"Step 2: Accessibility Scores","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":", look population’s perspective. location : Ai=∑jRjWr(dij) A_i = \\sum_j R_j W_r(d_{ij}) : RjR_j ratio calculated Step 1 Wr(d_ij)W_r(d\\_{ij}) another distance-based weight AiA_i final accessibility score tells us much service capacity people can reach, accounting distance competition users.","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"rasterized-formulas-a-different-perspective","dir":"Articles","previous_headings":"Okay, Time for Some Theory!","what":"Rasterized formulas: A Different Perspective","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"formulas traditionally written terms points ii jj, raster-based implementation thinks terms surfaces (~every point ii simultaneously). Let’s rewrite equations better reflect spax actually computes :","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"step-1-service-to-population-ratios-raster-form","dir":"Articles","previous_headings":"Okay, Time for Some Theory! > Rasterized formulas: A Different Perspective","what":"Step 1: Service-to-Population Ratios Raster Form","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"rj=sjsum(P⊙𝖶𝖽(Dj)) r_j = \\frac{s_j}{sum(P \\odot \\mathsf{W_d}(D_j))} : PP population density surface DjD_j travel time/distance surface facility jj 𝖶𝖽\\mathsf{W_d} demand-side weighting function ⊙\\odot represents element-wise (Hadamard) multiplication sum()sum() global sum entire surface sjs_j supply capacity facility jj rjr_j resulting ratio facility jj","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"step-2-accessibility-scores---raster-form","dir":"Articles","previous_headings":"Okay, Time for Some Theory! > Rasterized formulas: A Different Perspective","what":"Step 2: Accessibility Scores - Raster Form","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"=∑jrj𝖶𝗋(Dj) = \\sum_j r_j \\mathsf{W_r}(D_j) : AA now complete accessibility surface rather point-specific values. 𝖶𝗋\\mathsf{W_r} ratio-side weighting function raster-based formulation: Eliminates need iterate demand points ii Takes advantage efficient matrix operations Better reflects spax works continuous surfaces","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"from-formulas-to-functions","dir":"Articles","previous_headings":"Okay, Time for Some Theory!","what":"From Formulas to Functions","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"Let’s see formulas - traditional raster-based - translate actual code spax:  theoretical component becomes raster operation: Population Surface (PP): single raster showing population density/ Distance Surfaces (DjD_j): stack rasters, one per facility/ Weight Function (𝖶𝖽,𝖶𝗋\\mathsf{W_d}, \\mathsf{W_r}): Applied using calc_decay() real power comes spax chains operations together efficiently. Rather iterating individual points, : - Process entire surfaces - Use optimized matrix operations - Take advantage parallel processing (via terra) possible","code":"library(spax) library(terra) library(sf) library(tidyverse) #> Error in get(paste0(generic, \".\", class), envir = get_method_env()) :  #>   object 'type_sum.accel' not found  # Load our example data pop <- rast(u5pd) # Population density hospitals <- hc12_hos # Hospital locations distance <- rast(hos_iscr) # Travel times # Let's look at the basic components for one hospital example_hospital <- hospitals[1, ]  # Plot the fundamental surfaces par(mfrow = c(1, 3))  # Population surface (P) plot(pop, main = expression(\"Population Surface\" ~ (P)))  # Distance surface for facility j (D[j]) plot(distance[[1]], main = expression(\"Distance Surface\" ~ (D[j])))  # Weighted surface (W[d](D[j])) plot(calc_decay(distance[[1]], method = \"gaussian\", sigma = 30),      main = expression(\"Weighted Surface\" ~ (W[d](D[j]))))"},{"path":[]},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"distance-decay-from-theory-to-practice","dir":"Articles","previous_headings":"Building Blocks: Core Operations in spax","what":"Distance Decay: From Theory to Practice","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"Now understand theory, let’s look actually calculate weight functions Wd(dij)W_d(d_{ij}) 𝖶𝖽(Dj)\\mathsf{W_d}(D_j). weight function’s job simple - take distance value return weight 0 1. quickly weight decay distance? spax implements three classical decay functions (+ binary decay), offering different mathematical properties. Let’s align common reference point (50% decay 30 minutes) see behave:  function offers different mathematical perspective distance affects accessibility: Gaussian decay (W(d)=e−d2/(2σ2)W(d) = e^{-d^2/(2\\sigma^2)}): Models accessibility like bell curve, greatest change happening around 30-minute mark/ Exponential decay (W(d)=e−λdW(d) = e^{-\\lambda d}): additional minute travel reduces accessibility percentage/ Power decay (W(d)=d−βW(d) = d^{-\\beta}): Similar exponential early , maintains higher weights larger distances Let’s see functions transform distance surfaces:  beauty spax’s raster-based approach transformations happen - every cell distance surface gets converted weight simultaneously. ’re using R’s vectorized operations hood, works just efficiently whether ’re looking one facility hundred. Want create decay function? function takes distances returns weights work:","code":"# Create example data with functions aligned at 50% decay at 30 minutes example <- data.frame(x = seq(1,160,2))  example <- example |>   mutate(     gaussian_exp = calc_decay(x, method = \"gaussian\", sigma = 30),     exponential_exp = calc_decay(x, method = \"exponential\", sigma = 0.0196),     power_exp = calc_decay(x, method = \"power\", sigma = 0.1945)   )  # Plot ggplot(example, aes(x = x)) +   geom_line(aes(y = gaussian_exp, color = \"Gaussian\")) +   geom_line(aes(y = exponential_exp, color = \"Exponential\")) +   geom_line(aes(y = power_exp, color = \"Power\")) +   labs(     title = \"Distance Decay Functions\",     subtitle = \"All functions aligned at 50% decay at 30 minutes\",     x = \"Distance (minutes)\",     y = \"Weight\",     color = \"Function\"   ) +    scale_y_continuous(limits = c(0, 1)) +    theme_minimal() # Extract one distance surface to explore D_j <- distance[[1]] # Distance surface to our example hospital  # Calculate weights using different decay functions gaussian_weights <- calc_decay(D_j,   method = \"gaussian\",   sigma = 30 )  exponential_weights <- calc_decay(D_j,   method = \"exponential\",   sigma = 0.0196 )  power_weights <- calc_decay(D_j,   method = \"power\",   sigma = 0.1945 )  # Visualize how different functions handle distance par(mfrow = c(2, 2)) plot(D_j, main = \"Original Distance Surface (D_j)\") plot(gaussian_weights, main = \"Gaussian Decay\") plot(exponential_weights, main = \"Exponential Decay\") plot(power_weights, main = \"Power Decay\") # Custom decay combining distance threshold with Gaussian decay custom_decay <- function(distance, sigma = 30, threshold = 40) {   gaussian <- exp(-distance^2 / (2 * sigma^2))   gaussian[distance > threshold] <- 0  # Hard cutoff at threshold   return(gaussian) }  # Use it just like the built-in functions custom_weights <- calc_decay(D_j,    method = custom_decay,    sigma = 30,   threshold = 60 )  # Plot par(mfrow = c(1, 2)) plot(gaussian_weights, main = \"Gaussian Decay\") plot(custom_weights, main = \"Custom Decay\\n(thresholded Gaussian)\")"},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"managing-competition-weight-normalization","dir":"Articles","previous_headings":"Building Blocks: Core Operations in spax","what":"Managing Competition: Weight Normalization","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"Remember talked counting patients Step 1? ’s things get tricky. don’t handle overlapping service areas carefully, might count population multiple times. calc_normalize() calc_choice() comes :  Think normalization like adjusting recipe ingredients overlap. two hospitals serve area: Standard normalization: Forces weights sum 1, effectively splitting demand facilities Semi-normalization: adjusts weights facilities actually compete (sum > 1) normalization: Allows double-counting, might appropriate truly independent services raster formulation, becomes simple operation surfaces rather complex point-wise calculations.","code":"# Create weight surfaces for two nearby facilities W1 <- calc_decay(distance[[1]], method = \"gaussian\", sigma = 30) W2 <- calc_decay(distance[[2]], method = \"gaussian\", sigma = 30) facility_weights <- c(W1, W2)  # Compare different normalization approaches standard_norm <- calc_normalize(facility_weights, method = \"standard\") semi_norm <- calc_normalize(facility_weights, method = \"semi\")  # Visualize the effect of normalization par(mfrow = c(2, 2)) plot(sum(facility_weights),       main = \"Raw Weight Sum\\n(potential double-counting)\") plot(sum(standard_norm),       main = \"Standard Normalization\\n(sums to 1)\") plot(sum(semi_norm),       main = \"Semi-normalization\\n(prevents inflation)\")  # Show where normalization matters most overlap_areas <- sum(facility_weights) > 1 plot(overlap_areas,       main = \"Competition Areas\\n(where normalization matters)\")"},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"spreading-and-gathering-the-core-operations","dir":"Articles","previous_headings":"Building Blocks: Core Operations in spax","what":"Spreading and Gathering: The Core Operations","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"Now real workhorses spax: spread_weighted() gather_weighted() functions. implement summations formulas: Traditional: ∑iPiWd(dij)\\sum_i P_i W_d(d_{ij}) ∑jRjWr(dij)\\sum_j R_j W_r(d_{ij}) Raster: sum(P⊙𝖶𝖽(Dj))sum(P \\odot \\mathsf{W_d}(D_j)) ∑jrj𝖶𝗋(Dj)\\sum_j r_j \\mathsf{W_r}(D_j)  Think operations : - gather_weighted(): Collects weighted values surface facility-specific totals (vector) - spread_weighted(): Distributes facility-specific values back across service areas surface","code":"# Let's see these operations in action # First, calculate potential demand for our facilities potential_demand <- gather_weighted(   pop,           # Population surface (P)   standard_norm, # Normalized weights (W_d)   simplify = FALSE )  print(\"Potential demand by facility:\") #> [1] \"Potential demand by facility:\" head(potential_demand) #>   unit_id weighted_sum #> 1    c172     151148.2 #> 2    c173     140127.4  # Now calculate and spread accessibility supply_ratios <- potential_demand |>   mutate(     ratio = hospitals$s_doc[match(unit_id, hospitals$id)] / weighted_sum   )  print(\"Supply ratios:\") #> [1] \"Supply ratios:\" head(supply_ratios) #>   unit_id weighted_sum       ratio #> 1    c172     151148.2 0.003453564 #> 2    c173     140127.4 0.002290772  accessibility <- spread_weighted(   supply_ratios,    # Facility-specific ratios (r_j)   facility_weights, # Weight surfaces (W_r)   value_cols = \"ratio\" )  plot(accessibility, main = \"Final Accessibility Surface (A)\") plot(vect(bound0), add = TRUE)"},{"path":[]},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"putting-it-all-together-1","dir":"Articles","previous_headings":"Building Blocks: Core Operations in spax","what":"Putting It All Together","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"Now understand component, let’s see spax_e2sfca() orchestrates complete accessibility analysis. ’ll follow formula actual code:","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"the-complete-workflow","dir":"Articles","previous_headings":"Building Blocks: Core Operations in spax > Putting It All Together","what":"The Complete Workflow","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"Calculate Rj=Sj∑iPiWd(dij)R_j = \\frac{S_j}{\\sum_i P_i W_d(d_{ij})} facility Calculate rj=sjsum(P⊙𝖶𝖽(Dj))r_j = \\frac{s_j}{sum(P \\odot \\mathsf{W_d}(D_j))} facility Calculate Ai=∑jRjWr(dij)A_i = \\sum_j R_j W_r(d_{ij}) location Calculate =∑jrj𝖶𝗋(Dj)= \\sum_j r_j \\mathsf{W_r}(D_j) surface Let’s see step step:  can let spax_e2sfca() handle us:","code":"# Step 1a: Create distance decay weights facility_weights <- calc_decay(   distance,                    # Distance surfaces (D_j)   method = \"gaussian\",    sigma = 30 )  # Step 1b: Normalize weights to handle competition demand_weights <- calc_normalize(   facility_weights,           # W_d(D_j)   method = \"standard\"        # Prevents double-counting )  # Step 1c: Calculate potential demand for each facility potential_demand <- gather_weighted(   pop,             # Population surface (P)   demand_weights,  # Normalized weights   simplify = FALSE )  # Step 1d: Calculate supply-to-demand ratios supply_ratios <- potential_demand |>   mutate(     ratio = hospitals$s_doc[match(unit_id, hospitals$id)] / weighted_sum   )  # Step 2: Calculate final accessibility surface accessibility <- spread_weighted(   supply_ratios,     # Facility ratios (r_j)   facility_weights,  # Access-side weights (W_r)   value_cols = \"ratio\" )  # Visualize the final result plot(accessibility, main = \"E2SFCA Accessibility Surface\") plot(vect(bound0), add = TRUE) # The same calculation in one function call result <- spax_e2sfca(   demand = pop,   supply = hospitals |> st_drop_geometry(),   distance = distance,   decay_params = list(method = \"gaussian\", sigma = 30),   demand_normalize = \"standard\",   id_col = \"id\",   supply_cols = \"s_doc\" )  plot(result, main = \"E2SFCA Accessibility Scores\") plot(vect(bound0), add = TRUE)"},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"understanding-the-benefits","dir":"Articles","previous_headings":"Building Blocks: Core Operations in spax > Putting It All Together","what":"Understanding the Benefits","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"modular design offers several advantages: Flexibility: component can customized: Different decay functions Alternative normalization approaches Efficiency: Operations vectorized across entire surfaces Memory usage optimized large datasets Parallel processing beneficial Transparency: step clear inspectable Results can validated stage Intermediate outputs available analysis Extensibility: New components can added easily Custom workflows can built basic pieces Alternative accessibility measures can implemented","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-103-dissection.html","id":"whats-next","dir":"Articles","previous_headings":"Building Blocks: Core Operations in spax","what":"What’s Next?","title":"3. Under the Hood: Dissecting Spatial Accessibility Analysis","text":"Now understand spax works hood, might want explore: Understanding Raster Trade-offs: Learn memory performance implications raster-based approach Advanced Topics Accessibility: Demand adjustment, normalization, choice-based modeling [Coming Soon]","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"why-rasters-the-pros-cons-and-best-practices","dir":"Articles","previous_headings":"","what":"Why Rasters? The Pros, Cons, and Best Practices","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"’ve worked previous vignettes, ’ve seen spax relies heavily raster operations spatial accessibility analysis. choose approach? importantly, mean analysis? vignette, ’ll explore practical implications using raster-based operations, looking benefits challenges, providing concrete strategies optimizing workflows.","code":"# Load required packages library(spax) library(terra) library(pryr) # for memory tracking library(tidyverse) #> Error in get(paste0(generic, \".\", class), envir = get_method_env()) :  #>   object 'type_sum.accel' not found library(sf) library(bench) # fotr benchmarking"},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"understanding-the-raster-approach","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices","what":"Understanding the Raster Approach","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"Think raster giant spreadsheet laid study area. Instead tracking individual points complex polygons, store values regular grid cells. might seem simple, ’s simplicity makes raster operations powerful accessibility analysis. Let’s see action example data: calculate accessibility, nearly everything becomes grid operation: Population? grid density values Travel time? grid facility Distance decay? transformation grids Final accessibility? guessed - another grid Spatial accessibility often boils “map algebra”: function (Population density)×(Distance weights).\\text{function (Population density)} \\times \\text{(Distance weights)}. Rasters make algebra super direct: take population raster, multiply distance raster, sum result. Libraries like terra built cell--cell operations, spax simply arrange handy workflow.","code":"# Load example population density pop <- rast(u5pd)  # Quick look at what we're working with (pop) #> class       : SpatRaster  #> dimensions  : 509, 647, 1  (nrow, ncol, nlyr) #> resolution  : 520.4038, 520.4038  (x, y) #> extent      : 505646.5, 842347.8, 620843.7, 885729.2  (xmin, xmax, ymin, ymax) #> coord. ref. : +proj=utm +zone=47 +datum=WGS84 +units=m +no_defs  #> source(s)   : memory #> name        : tha_children_under_five_2020  #> min value   :                      0.00000  #> max value   :                     83.07421 cat(\"Total cells:\", ncell(pop), \"\\n\") #> Total cells: 329323"},{"path":[]},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"vectorized-operations-efficient-computation","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices > The Good: Why Raster Operations Works","what":"1. Vectorized Operations = Efficient Computation","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"One biggest advantages raster operations ’re naturally vectorized. Instead looping points polygons, can perform operations entire surfaces . Let’s see practice: results tell compelling story vectorized efficiency: total runtime increased 0.18s 0.96s (5x) time per cell actually decreased 5.47e-4 2.92e-5 milliseconds Operations vectorized across cells simultaneously Additional facilities leverage computational machinery Memory access patterns remain efficient even layers","code":"# First, let's create test datasets of different sizes create_test_distance <- function(n_facilities) {   # Take our original distance raster and replicate it   base_distance <- rast(hos_iscr)[[1]]  # Use first facility as template      # Create a stack with n copies   test_stack <- rep(base_distance, n_facilities)   names(test_stack) <- paste0(\"facility_\", 1:n_facilities)      return(test_stack) }  # Test with different numbers of facilities test_decay_scaling <- function(n_facilities) {   # Create test data   test_distances <- create_test_distance(n_facilities)      # Time the decay calculation   start_time <- Sys.time()   decay_weights <- calc_decay(     test_distances,     method = \"gaussian\",     sigma = 30   )   end_time <- Sys.time()      # Return timing and data size   return(list(     n_facilities = n_facilities,     n_cells = ncell(test_distances) * nlyr(test_distances),     runtime = as.numeric(difftime(end_time, start_time, units = \"secs\"))   )) }  # Run tests with dramatically different sizes facility_counts <- c(1, 10, 100) scaling_results <- lapply(facility_counts, test_decay_scaling)  # Create summary table scaling_summary <- tibble(   'Facilities' = sapply(scaling_results, `[[`, \"n_facilities\"),   'Total Cells' = sapply(scaling_results, `[[`, \"n_cells\"),   'Runtime (s)' = sapply(scaling_results, function(x)      round(x$runtime, 2)) ) |> mutate(   \"Time per Cell (ms)\" = `Runtime (s)` * 1000 / `Total Cells`,   'Total Cells' = format(`Total Cells`, big.mark=\",\") # Format after calculations ) # \"Computation Scaling with Facility Count:\" (scaling_summary) #> # A tibble: 3 × 4 #>   Facilities `Total Cells` `Runtime (s)` `Time per Cell (ms)` #>        <dbl> <chr>                 <dbl>                <dbl> #> 1          1 \"   329,323\"           0.02            0.0000607 #> 2         10 \" 3,293,230\"           0.13            0.0000395 #> 3        100 \"32,932,300\"           0.98            0.0000298"},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"consistent-data-structures","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices > The Good: Why Raster Operations Works","what":"2. Consistent Data Structures","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"decide raster resolution (e.g., 500m cells), everything—population, distance, decayed weight, final accessibility—can stored grid. means fewer mismatches, repeated coordinate transformations, swapping point sets polygons. ’re just piling new layers “sheet.”","code":"# Look at alignment of our key datasets check_alignment <- function(rast1, rast2, name1, name2) {   cat(\"\\nComparing\", name1, \"and\", name2, \":\\n\")   cat(\"Same resolution?\", all(res(rast1) == res(rast2)), \"\\n\")   cat(\"Same extent?\", all(ext(rast1) == ext(rast2)), \"\\n\")   cat(\"Same CRS?\", crs(rast1) == crs(rast2), \"\\n\") }  # Check population and distance rasters check_alignment(   rast(u5pd),    rast(hos_iscr),    \"Population\",    \"Distance\" ) #>  #> Comparing Population and Distance : #> Same resolution? TRUE  #> Same extent? TRUE  #> Same CRS? TRUE"},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"built-in-spatial-relationships","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices > The Good: Why Raster Operations Works","what":"3. Built-in Spatial Relationships","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"grid structure rasters automatically handles spatial interactions elegant way. instance, calculate accessibility, raster structure ensures : populated areas contribute demand calculations Distance decay automatically limited areas population NA values propagate naturally calculations","code":"# Look at one facility's service area facility_id <- hc12_hos$id[1]  # First facility facility_distance <- rast(hos_iscr)[[1]] pop <- rast(u5pd)  # Calculate decay weights decay_weights <- calc_decay(   facility_distance,    method = \"gaussian\",    sigma = 60 )  # The population raster automatically masks unpopulated areas weighted_pop <- pop * decay_weights  # Visualize how spatial relationships are preserved par(mfrow = c(1, 3))  plot(pop, main = \"Population\") plot(vect(hc12_hos[1,]), add = TRUE, pch = 16)  plot(decay_weights, main = \"Distance Decay\") plot(vect(hc12_hos[1,]), add = TRUE, pch = 16)  plot(weighted_pop, main = \"Population-Weighted Decay\") plot(vect(hc12_hos[1,]), add = TRUE, pch = 16)"},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"the-trade-offs-the-trade-offs-resolution-precision-and-computation","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices","what":"The Trade-Offs: The Trade-offs: Resolution, Precision, and Computation","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"exploring benefits raster operations, ’s time confront fundamental limitations. Every raster analysis starts critical choice: cell size use? seemingly simple decision affects computational efficiency spatial precision.","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"the-resolution-dilemma","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices > The Trade-Offs: The Trade-offs: Resolution, Precision, and Computation","what":"The Resolution Dilemma","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"Let’s explore resolution affects computation time analysis results: precision? Let’s look resolution affects accessibility results specific locations: Let’s visualize ’s happening spatial data:  results tell interesting story resolution trade-offs: Computational costs vary dramatically: Going 520m 4163m cells reduces grid 329,323 5,164 cells Processing time scales accordingly cell count level aggregation roughly quarters computational load accessibility patterns remain remarkably stable: Mean accessibility test province varies 2% across resolutions Even 4x coarser resolution (2082m), difference just 0.12% coarsest resolution (4163m) see noticeable change -2.20% stability suggests raster operations necessarily involve loss precision, overall patterns accessibility often remain robust across reasonable resolution choices. regional planning purposes, means can often use coarser resolutions without significantly compromising conclusions. key choosing resolution matches analytical needs.","code":"# Prepare test datasets at different resolutions first prep_test_data <- function(factor) {   # Aggregate both population and distance   pop_agg <- aggregate(rast(u5pd), fact = factor, fun = sum, na.rm = TRUE)   dist_agg <- aggregate(rast(hos_iscr), fact = factor, fun = mean, na.rm = TRUE)      return(list(pop = pop_agg, dist = dist_agg)) }  # Test computation time for actual analysis test_computation <- function(test_data) {   start_time <- Sys.time()      result <- spax_e2sfca(     demand = test_data$pop,     supply = hc12_hos |> st_drop_geometry(),     distance = test_data$dist,     decay_params = list(method = \"gaussian\", sigma = 30),     demand_normalize = \"standard\",     id_col = \"id\",     supply_cols = \"s_doc\",     snap = TRUE  # Fast mode for testing   )      end_time <- Sys.time()      # Return core metrics   list(     resolution = res(test_data$pop)[1],     ncells = ncell(test_data$pop),     runtime = as.numeric(difftime(end_time, start_time, units = \"secs\")),     result = result   ) }  # Test a range of resolutions factors <- c(1, 2, 4, 8)  # Each step doubles cell size test_data <- lapply(factors, prep_test_data) #> Warning: [aggregate] all values in argument 'fact' are 1, nothing to do #> Warning: [aggregate] all values in argument 'fact' are 1, nothing to do results <- lapply(test_data, test_computation)  # Create summary table scaling_summary <- tibble(   'Resolution (m)' = sapply(results, function(x) round(x$resolution)),   'Grid Cells' = sapply(results, function(x) x$ncells),   'Runtime (s)' = sapply(results, function(x) round(x$runtime, 2)) ) |> mutate(   'Time per Cell (μs)' = `Runtime (s)` * 1e6 / `Grid Cells`,   'Grid Cells' = format(`Grid Cells`, big.mark=\",\") )  # \"Performance Impact of Resolution:\" scaling_summary #> # A tibble: 4 × 4 #>   `Resolution (m)` `Grid Cells` `Runtime (s)` `Time per Cell (μs)` #>              <dbl> <chr>                <dbl>                <dbl> #> 1              520 \"329,323\"             2.68                 8.14 #> 2             1041 \" 82,620\"             0.74                 8.96 #> 3             2082 \" 20,736\"             0.17                 8.20 #> 4             4163 \"  5,184\"             0.07                13.5 # Select one province prov_exam <- bound1[1,]  # Compare mean accessibility values within a province extract_province_access <- function(result) {   # Extract mean accessibility for first province   # Extract zonal statistics   zonal_mean <- terra::extract(     result,     vect(prov_exam),     fun = mean,     na.rm = TRUE   )[,2]  # The second column contains the mean value      return(zonal_mean) }  # Create provincial comparison across resolutions access_comparison <- tibble(   'Resolution (m)' = sapply(results, function(x) round(x$resolution)),   'Mean Provincial Access' = sapply(results, function(x)      round(extract_province_access(x$result), 4)) ) |> mutate(   'Difference from Baseline (%)' = round(     (`Mean Provincial Access` - first(`Mean Provincial Access`)) /      first(`Mean Provincial Access`) * 100,      2   ) )  # Mean Accessibility in one province prov_exam$ADM1_EN # Name of the province #> [1] \"Songkhla\" access_comparison #> # A tibble: 4 × 3 #>   `Resolution (m)` `Mean Provincial Access` `Difference from Baseline (%)` #>              <dbl>                    <dbl>                          <dbl> #> 1              520                   0.0817                           0    #> 2             1041                   0.0816                          -0.12 #> 3             2082                   0.0815                          -0.24 #> 4             4163                   0.0798                          -2.33 # Create a 2x2 plot showing accessibility at different resolutions with province highlight par(mfrow = c(2, 2)) for(i in seq_along(results)) {   # Plot base accessibility surface   plot(results[[i]]$result,         main = sprintf(\"%0.0fm Resolution\\n%s cells\",                       results[[i]]$resolution,                      format(results[[i]]$ncells, big.mark=\",\")))   # Add full region boundary in thin black   plot(vect(bound0), add = TRUE, lwd = 0.5)   # Highlight our test province in thicker white   plot(vect(bound1[1,]), add = TRUE, border = \"red\", lwd = 3) }"},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"the-best-practices-optimizing-your-raster-workflow","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices","what":"The Best Practices: Optimizing Your Raster Workflow","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"Now understand power limitations raster-based analysis, let’s look concrete strategies getting spax avoiding common pitfalls.","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"start-coarse-then-refine","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices > The Best Practices: Optimizing Your Raster Workflow","what":"1. Start Coarse, Then Refine","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"Always prototype analysis coarser resolution first: Catch issues early computations fast Test different parameters efficiently simple workflow might look like:","code":"# Quick prototype at coarse resolution coarse_test <- spax_e2sfca(   demand = aggregate(rast(u5pd), fact = 4),  # 4x coarser   supply = hc12_hos |> st_drop_geometry(),   distance = aggregate(rast(hos_iscr), fact = 4),   decay_params = list(method = \"gaussian\", sigma = 30),   demand_normalize = \"standard\",   id_col = \"id\",   supply_cols = \"s_doc\" )  # Once satisfied, run at final resolution final_analysis <- spax_e2sfca(   demand = rast(u5pd),   supply = hc12_hos |> st_drop_geometry(),   distance = rast(hos_iscr),   decay_params = list(method = \"gaussian\", sigma = 30),   demand_normalize = \"standard\",   id_col = \"id\",   supply_cols = \"s_doc\" )"},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"match-resolution-to-analysis-scale","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices > The Best Practices: Optimizing Your Raster Workflow","what":"2. Match Resolution to Analysis Scale","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"Choose resolution based analytical needs & never use resolution finer coarsest input data","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"validate-against-known-totals","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices > The Best Practices: Optimizing Your Raster Workflow","what":"3. Validate Against Known Totals","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"Always check aggregated results known values: Population totals remain stable across resolutions Compare accessibility metrics key locations Verify patterns match expected behavior Consider zonal statistics administrative units","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"consider-your-analysis-goals","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices > The Best Practices: Optimizing Your Raster Workflow","what":"4. Consider Your Analysis Goals","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"Choose approach based matters : Need quick regional patterns? Use coarser resolutions Studying local variations? Invest finer resolution sensitivity analysis? Start coarse progressively refine Remember: finer resolution ≠ better analysis","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"document-your-choices","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices > The Best Practices: Optimizing Your Raster Workflow","what":"5. Document Your Choices","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"Always document resolution processing choices:","code":"# Example documentation structure analysis_metadata <- list(   resolution = res(rast(u5pd)),   extent = ext(rast(u5pd)),   cell_count = ncell(rast(u5pd)),   parameters = list(     decay = list(method = \"gaussian\", sigma = 30),     normalization = \"standard\"   ),   rationale = paste(     \"500m resolution chosen to balance\",     \"neighborhood-level detail with computational efficiency\"   ) )"},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"conclusion","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices","what":"Conclusion","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"Overall, raster operations pretty handy analyzing spatial accessibility. provide quick computations reliable data structures. However, ’s important keep mind balance resolution, precision, computation time. hope vignette helped understand trade-offs raster-based analysis bit better. Enjoy spax!","code":""},{"path":"https://songyosr.github.io/spax/articles/spax-104-raster-tradeoff.html","id":"see-also","dir":"Articles","previous_headings":"Why Rasters? The Pros, Cons, and Best Practices > Conclusion","what":"See Also:","title":"4. Why Rasters? The Pros, Cons, and Best Practices","text":"Getting Started spax Data Preparation Guide Dissecting spax: Understanding package’s inner workings","code":""},{"path":"https://songyosr.github.io/spax/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Songyos Rajborirug. Author, maintainer.","code":""},{"path":"https://songyosr.github.io/spax/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rajborirug S (2024). spax: Modular Raster-Based Spatial Accessibility Analysis. https://github.com/songyosr/spax.","code":"@Manual{,   title = {spax: Modular Raster-Based Spatial Accessibility Analysis},   author = {Songyos Rajborirug},   year = {2024},   url = {https://github.com/songyosr/spax}, }"},{"path":"https://songyosr.github.io/spax/index.html","id":"spax-spatial-accessibility-analysis-in-r","dir":"","previous_headings":"","what":"Modular Raster-Based Spatial Accessibility Analysis","title":"Modular Raster-Based Spatial Accessibility Analysis","text":"spax R package designed advanced spatial accessibility analysis, focusing Two-Step Floating Catchment Area (2SFCA) methods derivatives. package offers fresh perspective spatial accessibility raster-based computational approach modular design.","code":""},{"path":"https://songyosr.github.io/spax/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Modular Raster-Based Spatial Accessibility Analysis","text":"Computational Simplicity: Raster-based operations translate complex spatial relationships simple matrix calculations Modular Design: Functions work like LEGO bricks - mix match components build custom analysis workflows Complex Demand Handling: Support continuous population surfaces, letting work high-resolution demand data Monte Carlo Integration: Built-tools uncertainty analysis stochastic demand modeling","code":""},{"path":"https://songyosr.github.io/spax/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Modular Raster-Based Spatial Accessibility Analysis","text":"can install development version spax GitHub :","code":"# install.packages(\"pak\") pak::pak(\"Songyosr/spax\")"},{"path":"https://songyosr.github.io/spax/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Modular Raster-Based Spatial Accessibility Analysis","text":"’s spax’s modular design works practice, analyzing healthcare accessibility Thailand’s Region 12:  example demonstrates key features spax: Working continuous population surfaces (demand) Handling multiple supply indicators simultaneously Gaussian distance decay realistic accessibility modeling","code":"library(spax) library(terra) library(sf)  # Load example data (already included in package) pop <- rast(u5pd)  # Under-5 population density hospitals <- hc12_hos  # Hospital locations and capacity distance <- rast(hos_iscr)  # Travel time to hospitals  # Calculate accessibility using Enhanced 2SFCA accessibility <- spax_e2sfca(   demand = pop,  # Population density   supply = hospitals |> st_drop_geometry(),  # Hospital capacity   distance = distance,  # Travel times   decay_params = list(     method = \"gaussian\",     sigma = 30  # 30-minute characteristic distance   ),   demand_normalize = \"standard\",  # Prevent demand inflation   id_col = \"id\",   supply_cols = c(\"s_doc\", \"s_nurse\")  # Analyze both doctors and nurses )  # Plot results plot(accessibility,       main = c(\"Access to Doctors\", \"Access to Nurses\")) plot(vect(bound0), add = TRUE)"},{"path":"https://songyosr.github.io/spax/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"Modular Raster-Based Spatial Accessibility Analysis","text":"Check vignettes detailed guidance:","code":""},{"path":"https://songyosr.github.io/spax/index.html","id":"see-also","dir":"","previous_headings":"","what":"See Also","title":"Modular Raster-Based Spatial Accessibility Analysis","text":"Getting Started spax Data Preparation Guide Dissecting spax: Understanding package’s inner workings Understanding Raster Trade-offs","code":""},{"path":"https://songyosr.github.io/spax/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Modular Raster-Based Spatial Accessibility Analysis","text":"Truth , ’m just getting started spax. ’d love board help shape future spatial accessibility analysis R. Please feel free submit Pull Request. major changes, please open issue first discuss like change.","code":""},{"path":"https://songyosr.github.io/spax/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Modular Raster-Based Spatial Accessibility Analysis","text":"project licensed MIT License - see LICENSE file details.","code":""},{"path":"https://songyosr.github.io/spax/reference/bound0.html","id":null,"dir":"Reference","previous_headings":"","what":"Thailand Health Region 12 Boundary Area - Boundary — bound0","title":"Thailand Health Region 12 Boundary Area - Boundary — bound0","text":"dataset representing geographic boundary Health Region 12 Thailand without administrative details.","code":""},{"path":"https://songyosr.github.io/spax/reference/bound0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Thailand Health Region 12 Boundary Area - Boundary — bound0","text":"","code":"bound0"},{"path":"https://songyosr.github.io/spax/reference/bound0.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Thailand Health Region 12 Boundary Area - Boundary — bound0","text":"`sf` object following attributes: geometry geometry column containing spatial polygons boundary.","code":""},{"path":"https://songyosr.github.io/spax/reference/bound0.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Thailand Health Region 12 Boundary Area - Boundary — bound0","text":"Data processed Thailand's official administrative boundaries, available [Humanitarian Data Exchange (HDX)](https://data.humdata.org/dataset/thailand-administrative-boundaries).","code":""},{"path":"https://songyosr.github.io/spax/reference/bound0.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Thailand Health Region 12 Boundary Area - Boundary — bound0","text":"dataset includes boundary area Health Region 12, useful masking spatial extent analysis.","code":""},{"path":"https://songyosr.github.io/spax/reference/bound0.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Thailand Health Region 12 Boundary Area - Boundary — bound0","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) library(ggplot2)  # Load the dataset bound0 # already lazy-loaded - no need to run data(bound0)  # Plot the boundary ggplot(bound0) +   geom_sf(fill = \"lightblue\") +   ggtitle(\"Thailand Region 12 Boundary Area\") } # }"},{"path":"https://songyosr.github.io/spax/reference/bound1.html","id":null,"dir":"Reference","previous_headings":"","what":"Thailand Region 12 ADM1 Boundaries with Attributes — bound1","title":"Thailand Region 12 ADM1 Boundaries with Attributes — bound1","text":"dataset representing administrative boundaries (ADM1) Region 12 Thailand, along key attributes.","code":""},{"path":"https://songyosr.github.io/spax/reference/bound1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Thailand Region 12 ADM1 Boundaries with Attributes — bound1","text":"","code":"bound1"},{"path":"https://songyosr.github.io/spax/reference/bound1.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Thailand Region 12 ADM1 Boundaries with Attributes — bound1","text":"`sf` object 7 features following attributes: Shape_Leng Length boundary map units. Shape_Area Area boundary map units. ADM1_EN Province name English. ADM1_TH Province name Thai. ADM1_PCODE Province administrative code. ADM0_EN Country name English. ADM0_TH Country name Thai. ADM0_PCODE Country administrative code. date Date boundary created. validOn Date boundary became valid. geometry geometry column containing spatial polygons.","code":""},{"path":"https://songyosr.github.io/spax/reference/bound1.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Thailand Region 12 ADM1 Boundaries with Attributes — bound1","text":"Data processed Thailand's official administrative boundaries, available [Humanitarian Data Exchange (HDX)](https://data.humdata.org/dataset/thailand-administrative-boundaries).","code":""},{"path":"https://songyosr.github.io/spax/reference/bound1.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Thailand Region 12 ADM1 Boundaries with Attributes — bound1","text":"dataset provides detailed administrative information Region 12 provinces Thailand.","code":""},{"path":"https://songyosr.github.io/spax/reference/bound1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Thailand Region 12 ADM1 Boundaries with Attributes — bound1","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) library(ggplot2)  bound1 # already lazy-loaded - no need to run data(bound1)  # Plot the ADM1 boundaries with province names ggplot(bound1) +   geom_sf(aes(fill = ADM1_EN)) +   geom_sf_label(aes(label = ADM1_EN)) +   ggtitle(\"Thailand Region 12 ADM1 Boundaries\") } # }"},{"path":"https://songyosr.github.io/spax/reference/calc_choice.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Spatial Choice Probabilities — calc_choice","title":"Compute Spatial Choice Probabilities — calc_choice","text":"Converts spatial weights choice probabilities. used attractiveness values, implements Huff model logic. Without attractiveness, behaves like standard weight normalization.","code":""},{"path":"https://songyosr.github.io/spax/reference/calc_choice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Spatial Choice Probabilities — calc_choice","text":"","code":"calc_choice(weights, attractiveness = NULL, alpha = 1, a0 = 0, snap = FALSE)"},{"path":"https://songyosr.github.io/spax/reference/calc_choice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Spatial Choice Probabilities — calc_choice","text":"weights Multi-layer SpatRaster spatial weights (e.g., calc_decay) attractiveness Optional numeric vector facility attractiveness values alpha Numeric parameter attractiveness sensitivity (default = 1) a0 Non-negative numeric value representing outside option weight (default = 0) snap Logical; TRUE enables fast computation mode : - Minimal validation - Essential preprocessing - name/attribute assignment use inputs known valid.","code":""},{"path":"https://songyosr.github.io/spax/reference/calc_choice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Spatial Choice Probabilities — calc_choice","text":"SpatRaster stack choice probabilities (layers sum 1 location)","code":""},{"path":"https://songyosr.github.io/spax/reference/calc_choice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Spatial Choice Probabilities — calc_choice","text":"","code":"library(terra) #> terra 1.8.5 # Using pre-computed isochrone distances and hospital data distance_raster <- rast(hos_iscr) # Already lazy loaded in raster format  # Calculate decay weights using gaussian decay weights <- calc_decay(distance_raster, method = \"gaussian\", sigma = 30)  # Basic usage (equivalent to calc_normalize) p1 <- calc_choice(weights)  # With Huff model using number of doctors as attractiveness p2 <- calc_choice(weights,   attractiveness = hc12_hos$s_doc, # Number of doctors   alpha = 1.5 )  # Plot to compare par(mfrow = c(1, 2)) # Set up 2 panels side by side plot(p1[[1]], main = \"Basic Choice Prob.\") plot(p2[[1]], main = \"Doctor-weighted Choice Prob.\")   # With outside option (a0) p3 <- calc_choice(weights,   attractiveness = hc12_hos$s_doc,   a0 = 0.1 )"},{"path":"https://songyosr.github.io/spax/reference/calc_decay.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Spatial Distance Decay Weights — calc_decay","title":"Calculate Spatial Distance Decay Weights — calc_decay","text":"Calculate weights using different spatial decay functions custom function. Supports built-methods custom decay functions. decay weights represent influence interaction strength diminishes distance.","code":""},{"path":"https://songyosr.github.io/spax/reference/calc_decay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Spatial Distance Decay Weights — calc_decay","text":"","code":"calc_decay(distance, method = \"gaussian\", sigma = NULL, snap = FALSE, ...)"},{"path":"https://songyosr.github.io/spax/reference/calc_decay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Spatial Distance Decay Weights — calc_decay","text":"distance Numeric vector, matrix, SpatRaster distances method Character string specifying decay function custom function: \"gaussian\", \"exponential\", \"power\", \"inverse\", \"binary\", function(distance, ...) sigma Parameter controlling rate decay snap Logical; TRUE, skip input validation ... Additional parameters passed custom decay functions","code":""},{"path":"https://songyosr.github.io/spax/reference/calc_decay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Spatial Distance Decay Weights — calc_decay","text":"Object class input containing decay weights","code":""},{"path":"https://songyosr.github.io/spax/reference/calc_decay.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Spatial Distance Decay Weights — calc_decay","text":"","code":"if (FALSE) { # \\dontrun{ library(terra) library(spax)  # Create a simple distance raster (10x10 grid) r <- rast(nrows = 10, ncols = 10, xmin = 0, xmax = 10, ymin = 0, ymax = 10) values(r) <- 1:100 # Distance values  # 1. Basic usage with different methods ---- # Gaussian decay w1 <- calc_decay(r, method = \"gaussian\", sigma = 30)  # Exponential decay w2 <- calc_decay(r, method = \"exponential\", sigma = 0.1)  # Power decay w3 <- calc_decay(r, method = \"power\", sigma = 2)  # Binary threshold w4 <- calc_decay(r, method = \"binary\", sigma = 50)  # Plot to compare plot(c(w1, w2, w3, w4))  # 2. Custom decay function ---- # Create a custom decay function that combines gaussian and power custom_decay <- function(distance, sigma = 30, power = 2, ...) {   gaussian <- exp(-(distance^2) / (2 * sigma^2))   power_decay <- distance^(-power)   return(gaussian * power_decay) }  w5 <- calc_decay(r, method = custom_decay, sigma = 30, power = 1.5)  # 3. Working with multiple facilities ---- # Create distance rasters for 3 facilities distances <- rast(replicate(3, r)) # Stack of 3 identical rasters names(distances) <- c(\"facility1\", \"facility2\", \"facility3\")  # Calculate decay weights for all facilities weights <- calc_decay(distances, method = \"gaussian\", sigma = 30)  # 4. Performance optimization ---- # Use snap=TRUE when calling repeatedly in performance-critical code weights_fast <- calc_decay(distances, method = \"gaussian\", sigma = 30, snap = TRUE)  # 5. Compare decay parameters ---- # Create a sequence of sigma values sigmas <- c(10, 20, 30, 40, 50)  # Calculate and plot weights for each sigma weights_list <- lapply(sigmas, function(s) {   calc_decay(r, method = \"gaussian\", sigma = s) })  # Convert to SpatRaster stack and plot weight_stack <- rast(weights_list) names(weight_stack) <- paste0(\"sigma_\", sigmas) plot(weight_stack) } # }"},{"path":"https://songyosr.github.io/spax/reference/calc_normalize.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize Spatial Weights — calc_normalize","title":"Normalize Spatial Weights — calc_normalize","text":"Normalizes weights using different methods support outside options.","code":""},{"path":"https://songyosr.github.io/spax/reference/calc_normalize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize Spatial Weights — calc_normalize","text":"","code":"calc_normalize(   x,   method = \"standard\",   ref_value = NULL,   a0 = 0,   snap = FALSE,   ... )"},{"path":"https://songyosr.github.io/spax/reference/calc_normalize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize Spatial Weights — calc_normalize","text":"x Numeric vector, matrix, SpatRaster weights method Character string specifying normalization method: - \"standard\": Divide sum + a0 (default) - \"semi\": Normalize sum + a0 > 1 - \"reference\": Normalize reference value - \"identity\": Return unchanged - custom function(x, ...) ref_value Optional reference value \"reference\" method a0 Non-negative numeric value representing outside option weight (default = 0) snap Logical; TRUE, avoid input validation ... Additional arguments passed custom normalization function","code":""},{"path":"https://songyosr.github.io/spax/reference/calc_normalize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalize Spatial Weights — calc_normalize","text":"Object class input containing normalized weights","code":""},{"path":"https://songyosr.github.io/spax/reference/calc_normalize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalize Spatial Weights — calc_normalize","text":"","code":"if (FALSE) { # \\dontrun{ library(terra)  # Example 1: Basic vector normalization weights <- c(2, 3, 5) calc_normalize(weights) # Returns c(0.2, 0.3, 0.5)  # Example 2: Semi-normalization with vector small_weights <- c(0.2, 0.3, 0.4) calc_normalize(small_weights, method = \"semi\") # Returns original values  large_weights <- c(0.5, 0.7, 0.9) calc_normalize(large_weights, method = \"semi\") # Normalizes since sum > 1  # Example 3: Working with raster data r <- rast(nrows = 10, ncols = 10) values(r) <- runif(100) # Random weights norm_rast <- calc_normalize(r) # Values sum to 1  # Example 4: Using outside option (a0) weights_with_outside <- c(2, 3, 5) calc_normalize(weights_with_outside, a0 = 10) # Includes outside option weight  # Example 5: Reference normalization values <- c(10, 15, 25) calc_normalize(values, method = \"reference\", ref_value = 20)  # Example 6: Custom normalization function custom_norm <- function(x) {   x / (max(x, na.rm = TRUE) + min(x, na.rm = TRUE)) } calc_normalize(values, method = custom_norm)  # Example 7: Multi-layer raster normalization r_stack <- c(r, r * 2, r * 0.5) # Create 3-layer raster names(r_stack) <- c(\"layer1\", \"layer2\", \"layer3\") norm_stack <- calc_normalize(r_stack) # Normalizes each cell across layers  # Example 8: Handling NA values weights_with_na <- c(2, NA, 5, 3) calc_normalize(weights_with_na) # NA values are handled appropriately } # }"},{"path":"https://songyosr.github.io/spax/reference/compute_access.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate spatial accessibility using weighted surfaces — compute_access","title":"Calculate spatial accessibility using weighted surfaces — compute_access","text":"General-purpose function calculate spatial accessibility combining demand-side supply-side weighted distributions. Supports multiple supply measures flexible weight specifications.","code":""},{"path":"https://songyosr.github.io/spax/reference/compute_access.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate spatial accessibility using weighted surfaces — compute_access","text":"","code":"compute_access(   demand,   supply,   demand_weights,   access_weights,   id_col = NULL,   supply_cols = NULL,   indicator_names = NULL,   snap = FALSE )"},{"path":"https://songyosr.github.io/spax/reference/compute_access.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate spatial accessibility using weighted surfaces — compute_access","text":"demand SpatRaster representing spatial distribution demand supply vector, matrix, data.frame containing supply capacity values. using sf object, please use st_drop_geometry() first. demand_weights Multi-layer SpatRaster demand-side weights access_weights Multi-layer SpatRaster accessibility-side weights id_col Character; column name facility IDs supply data.frame supply_cols Character vector; names supply columns supply data.frame indicator_names Character vector; custom names output accessibility layers snap Logical; TRUE enable fast computation mode (default = FALSE)","code":""},{"path":"https://songyosr.github.io/spax/reference/compute_access.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate spatial accessibility using weighted surfaces — compute_access","text":"SpatRaster accessibility scores","code":""},{"path":"https://songyosr.github.io/spax/reference/compute_iterative.html","id":null,"dir":"Reference","previous_headings":"","what":"Full iterative computation with history tracking — compute_iterative","title":"Full iterative computation with history tracking — compute_iterative","text":"Implements iterative floating catchment area method comprehensive output including convergence history detailed state tracking. version supports single-layer time-series demand patterns.","code":""},{"path":"https://songyosr.github.io/spax/reference/compute_iterative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Full iterative computation with history tracking — compute_iterative","text":"","code":"compute_iterative(   supply,   weights,   demand,   lambda = 0.5,   max_iter = 100,   tolerance = 1e-06,   window_size = 5,   convergence_type = \"utilization\",   debug = FALSE )"},{"path":"https://songyosr.github.io/spax/reference/compute_iterative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Full iterative computation with history tracking — compute_iterative","text":"supply Numeric vector facility capacities weights Multi-layer SpatRaster spatial weights distance decay demand SpatRaster demand (single layer matching max_iter) lambda Learning rate 0 1 max_iter Maximum iterations attempt tolerance Convergence threshold window_size Size rolling window convergence checking convergence_type Character; \"utilization\" \"ratio\" convergence metric debug Logical; TRUE provides detailed convergence information","code":""},{"path":"https://songyosr.github.io/spax/reference/compute_iterative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Full iterative computation with history tracking — compute_iterative","text":"List containing: iterations: Number iterations completed converged: Logical indicating convergence status state: Array historical state values [iterations, facilities, metrics] util_probs: Final utilization probability surfaces convergence: List convergence details","code":""},{"path":"https://songyosr.github.io/spax/reference/compute_iterative_fast.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast version of iterative computation for parameter tuning — compute_iterative_fast","title":"Fast version of iterative computation for parameter tuning — compute_iterative_fast","text":"Optimized version returns utilization vector, designed parameter tuning scenarios intermediate results history needed.","code":""},{"path":"https://songyosr.github.io/spax/reference/compute_iterative_fast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast version of iterative computation for parameter tuning — compute_iterative_fast","text":"","code":"compute_iterative_fast(   supply,   weights,   demand,   lambda = 0.5,   max_iter = 100,   tolerance = 1e-06,   window_size = 5 )"},{"path":"https://songyosr.github.io/spax/reference/compute_iterative_fast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast version of iterative computation for parameter tuning — compute_iterative_fast","text":"supply Numeric vector facility capacities weights Multi-layer SpatRaster spatial weights distance decay demand SpatRaster demand (single layer matching max_iter) lambda Learning rate 0 1 max_iter Maximum iterations attempt tolerance Convergence threshold window_size Size rolling window convergence checking","code":""},{"path":"https://songyosr.github.io/spax/reference/compute_iterative_fast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast version of iterative computation for parameter tuning — compute_iterative_fast","text":"Numeric vector predicted utilization facilities","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_calc_choice.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function for core choice cvalidation — .chck_calc_choice","title":"Internal function for core choice cvalidation — .chck_calc_choice","text":"Internal function core choice cvalidation","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_calc_choice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function for core choice cvalidation — .chck_calc_choice","text":"","code":".chck_calc_choice(weights, attractiveness = NULL, alpha = 1, a0 = 0)"},{"path":"https://songyosr.github.io/spax/reference/dot-chck_compute_access.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate inputs for compute_access — .chck_compute_access","title":"Validate inputs for compute_access — .chck_compute_access","text":"Validate inputs compute_access","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_compute_access.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate inputs for compute_access — .chck_compute_access","text":"","code":".chck_compute_access(   demand,   supply,   demand_weights,   access_weights,   id_col = NULL,   supply_cols = NULL,   indicator_names = NULL )"},{"path":"https://songyosr.github.io/spax/reference/dot-chck_compute_access.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate inputs for compute_access — .chck_compute_access","text":"demand SpatRaster representing spatial distribution demand supply vector, matrix, data.frame containing supply capacity values demand_weights Multi-layer SpatRaster demand-side weights access_weights Multi-layer SpatRaster accessibility-side weights id_col Character; column name facility IDs supply data.frame supply_cols Character vector; names supply columns supply data.frame indicator_names Character vector; custom names output accessibility layers","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_decay.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate inputs for decay calculation — .chck_decay","title":"Validate inputs for decay calculation — .chck_decay","text":"Validate inputs decay calculation","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_decay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate inputs for decay calculation — .chck_decay","text":"","code":".chck_decay(distance, method, sigma = NULL, snap = FALSE)"},{"path":"https://songyosr.github.io/spax/reference/dot-chck_decay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate inputs for decay calculation — .chck_decay","text":"distance Numeric vector, matrix, SpatRaster distances method Character string function specifying decay method sigma Numeric parameter controlling decay rate snap Logical validation skipping","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_e2sfca.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate inputs for spax_e2sfca — .chck_e2sfca","title":"Validate inputs for spax_e2sfca — .chck_e2sfca","text":"Validate inputs spax_e2sfca","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_e2sfca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate inputs for spax_e2sfca — .chck_e2sfca","text":"","code":".chck_e2sfca(   demand,   supply,   distance,   decay_params,   demand_normalize,   id_col = NULL,   supply_cols = NULL )"},{"path":"https://songyosr.github.io/spax/reference/dot-chck_e2sfca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate inputs for spax_e2sfca — .chck_e2sfca","text":"demand SpatRaster representing spatial distribution demand supply vector, matrix, data.frame containing supply capacity values distance SpatRaster stack travel times/distances facilities decay_params List parameters decay function demand_normalize Character specifying normalization method id_col Character; column name facility IDs supply data.frame supply_cols Character vector; names supply columns supply data.frame","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_gather_weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate inputs for gather_weighted — .chck_gather_weighted","title":"Validate inputs for gather_weighted — .chck_gather_weighted","text":"Validate inputs gather_weighted","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_gather_weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate inputs for gather_weighted — .chck_gather_weighted","text":"","code":".chck_gather_weighted(values, weights, na.rm)"},{"path":"https://songyosr.github.io/spax/reference/dot-chck_gather_weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate inputs for gather_weighted — .chck_gather_weighted","text":"values SpatRaster values weights SpatRaster weights na.rm Logical NA handling","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_n_convert_pmf.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and convert input to PMF — .chck_n_convert_pmf","title":"Check and convert input to PMF — .chck_n_convert_pmf","text":"Check convert input PMF","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_n_convert_pmf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and convert input to PMF — .chck_n_convert_pmf","text":"","code":".chck_n_convert_pmf(x)"},{"path":"https://songyosr.github.io/spax/reference/dot-chck_n_convert_pmf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and convert input to PMF — .chck_n_convert_pmf","text":"x SpatRaster input","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_n_convert_pmf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and convert input to PMF — .chck_n_convert_pmf","text":"List PMF raster total population","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_sample_pmf.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate inputs for sample_pmf — .chck_sample_pmf","title":"Validate inputs for sample_pmf — .chck_sample_pmf","text":"Validate inputs sample_pmf","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_sample_pmf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate inputs for sample_pmf — .chck_sample_pmf","text":"","code":".chck_sample_pmf(x, n, size, prob, method, iterations, evolve_prop, snap)"},{"path":"https://songyosr.github.io/spax/reference/dot-chck_sample_pmf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate inputs for sample_pmf — .chck_sample_pmf","text":"x SpatRaster input n Sample size size Population size prob Probability parameter method Sampling method iterations Number iterations evolve_prop Evolution proportion snap Logical snap mode","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_spax_ifca.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate inputs for spax_ifca — .chck_spax_ifca","title":"Validate inputs for spax_ifca — .chck_spax_ifca","text":"Validate inputs spax_ifca","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_spax_ifca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate inputs for spax_ifca — .chck_spax_ifca","text":"","code":".chck_spax_ifca(   distance_raster,   demand,   supply,   decay_params,   lambda,   max_iter,   tolerance,   window_size )"},{"path":"https://songyosr.github.io/spax/reference/dot-chck_spax_ifca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate inputs for spax_ifca — .chck_spax_ifca","text":"distance_raster SpatRaster stack travel times/distances facilities demand SpatRaster demand (single layer matching max_iter) supply Numeric vector facility capacities decay_params List parameters decay function lambda Learning rate 0 1 max_iter Maximum number iterations tolerance Convergence tolerance threshold window_size Size rolling window convergence","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_spax_ifca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate inputs for spax_ifca — .chck_spax_ifca","text":"Invisibly returns TRUE validations pass.","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_spread_weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate inputs for spread_weighted — .chck_spread_weighted","title":"Validate inputs for spread_weighted — .chck_spread_weighted","text":"Validate inputs spread_weighted","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_spread_weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate inputs for spread_weighted — .chck_spread_weighted","text":"","code":".chck_spread_weighted(values, weights, value_cols = NULL)"},{"path":"https://songyosr.github.io/spax/reference/dot-chck_spread_weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate inputs for spread_weighted — .chck_spread_weighted","text":"values Numeric vector, matrix data.frame values weights Multi-layer SpatRaster weights value_cols Column names values data.frame","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_transform_pmf.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate inputs for PMF transformation — .chck_transform_pmf","title":"Validate inputs for PMF transformation — .chck_transform_pmf","text":"Validate inputs PMF transformation","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_transform_pmf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate inputs for PMF transformation — .chck_transform_pmf","text":"","code":".chck_transform_pmf(x, snap = FALSE)"},{"path":"https://songyosr.github.io/spax/reference/dot-chck_transform_pmf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate inputs for PMF transformation — .chck_transform_pmf","text":"x SpatRaster validated snap Logical; TRUE skip validation","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-chck_transform_pmf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate inputs for PMF transformation — .chck_transform_pmf","text":"Invisible TRUE valid, error otherwise","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-compute_access_core.html","id":null,"dir":"Reference","previous_headings":"","what":"Core computation for accessibility calculation — .compute_access_core","title":"Core computation for accessibility calculation — .compute_access_core","text":"Core computation accessibility calculation","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-compute_access_core.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Core computation for accessibility calculation — .compute_access_core","text":"","code":".compute_access_core(   demand,   supply_values,   demand_weights,   access_weights,   indicator_names = NULL )"},{"path":"https://songyosr.github.io/spax/reference/dot-compute_access_core.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Core computation for accessibility calculation — .compute_access_core","text":"demand SpatRaster demand supply_values Matrix supply values demand_weights SpatRaster demand-side weights access_weights SpatRaster accessibility-side weights indicator_names Character vector names output layers","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-compute_access_core.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Core computation for accessibility calculation — .compute_access_core","text":"SpatRaster accessibility scores","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-gather_weighted_core.html","id":null,"dir":"Reference","previous_headings":"","what":"Core computation for gather_weighted — .gather_weighted_core","title":"Core computation for gather_weighted — .gather_weighted_core","text":"Core computation gather_weighted","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-gather_weighted_core.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Core computation for gather_weighted — .gather_weighted_core","text":"","code":".gather_weighted_core(values, weights, na.rm = TRUE)"},{"path":"https://songyosr.github.io/spax/reference/dot-help_add_0facilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Reintegrate zero-supply facilities into results — .help_add_0facilities","title":"Reintegrate zero-supply facilities into results — .help_add_0facilities","text":"Reintegrate zero-supply facilities results","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_add_0facilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reintegrate zero-supply facilities into results — .help_add_0facilities","text":"","code":".help_add_0facilities(results, zero_map, fill = 0)"},{"path":"https://songyosr.github.io/spax/reference/dot-help_add_0facilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reintegrate zero-supply facilities into results — .help_add_0facilities","text":"results Numeric vector results valid facilities zero_map Logical vector marking zero-supply facilities fill Value use zero-supply facilities","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_add_0facilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reintegrate zero-supply facilities into results — .help_add_0facilities","text":"Numeric vector zero facilities reintegrated","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_calc_choice_core.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function for core choice computation — .help_calc_choice_core","title":"Internal function for core choice computation — .help_calc_choice_core","text":"Internal function core choice computation","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_calc_choice_core.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function for core choice computation — .help_calc_choice_core","text":"","code":".help_calc_choice_core(weights, attractiveness, alpha, a0)"},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_binary.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for binary decay weight computation — .help_decay_binary","title":"Helper function for binary decay weight computation — .help_decay_binary","text":"Helper function binary decay weight computation","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_binary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for binary decay weight computation — .help_decay_binary","text":"","code":".help_decay_binary(distance, sigma = 97.5, ...)"},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_binary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for binary decay weight computation — .help_decay_binary","text":"distance Numeric vector distances sigma Distance threshold ... Additional parameters (used binary decay)","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_binary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for binary decay weight computation — .help_decay_binary","text":"Numeric vector weights","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_exponential.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for exponential decay weight computation — .help_decay_exponential","title":"Helper function for exponential decay weight computation — .help_decay_exponential","text":"Helper function exponential decay weight computation","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_exponential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for exponential decay weight computation — .help_decay_exponential","text":"","code":".help_decay_exponential(distance, sigma, ...)"},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_exponential.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for exponential decay weight computation — .help_decay_exponential","text":"distance Numeric vector distances sigma Rate parameter controlling steepness decay ... Additional parameters (used exponential decay)","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_exponential.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for exponential decay weight computation — .help_decay_exponential","text":"Numeric vector weights","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_gaussian.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for Gaussian decay weight computation — .help_decay_gaussian","title":"Helper function for Gaussian decay weight computation — .help_decay_gaussian","text":"Helper function Gaussian decay weight computation","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_gaussian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for Gaussian decay weight computation — .help_decay_gaussian","text":"","code":".help_decay_gaussian(distance, sigma = 11.64884, ...)"},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_gaussian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for Gaussian decay weight computation — .help_decay_gaussian","text":"distance Numeric vector distances sigma Standard deviation parameter controlling spread ... Additional parameters (used gaussian decay)","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_gaussian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for Gaussian decay weight computation — .help_decay_gaussian","text":"Numeric vector weights","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_inverse.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for inverse distance weight computation — .help_decay_inverse","title":"Helper function for inverse distance weight computation — .help_decay_inverse","text":"Helper function inverse distance weight computation","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_inverse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for inverse distance weight computation — .help_decay_inverse","text":"","code":".help_decay_inverse(distance, c = 1, ...)"},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_inverse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for inverse distance weight computation — .help_decay_inverse","text":"distance Numeric vector distances c Constant prevent division zero ... Additional parameters (used inverse decay)","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_inverse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for inverse distance weight computation — .help_decay_inverse","text":"Numeric vector weights","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_power.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for power decay weight computation — .help_decay_power","title":"Helper function for power decay weight computation — .help_decay_power","text":"Helper function power decay weight computation","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_power.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for power decay weight computation — .help_decay_power","text":"","code":".help_decay_power(distance, sigma, ...)"},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_power.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for power decay weight computation — .help_decay_power","text":"distance Numeric vector distances sigma Exponent parameter controlling rate decay ... Additional parameters (used power decay)","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_decay_power.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function for power decay weight computation — .help_decay_power","text":"Numeric vector weights","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_est_new_sample.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate new sample — .help_est_new_sample","title":"Estimate new sample — .help_est_new_sample","text":"Estimate new sample","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_est_new_sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate new sample — .help_est_new_sample","text":"","code":".help_est_new_sample(input_vector, evolve_prop)"},{"path":"https://songyosr.github.io/spax/reference/dot-help_format_gather.html","id":null,"dir":"Reference","previous_headings":"","what":"Format output for gather_weighted — .help_format_gather","title":"Format output for gather_weighted — .help_format_gather","text":"Format output gather_weighted","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_format_gather.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format output for gather_weighted — .help_format_gather","text":"","code":".help_format_gather(weighted_sums, weights, values = NULL)"},{"path":"https://songyosr.github.io/spax/reference/dot-help_gen_sample_size.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute sample sizes for each iteration — .help_gen_sample_size","title":"Compute sample sizes for each iteration — .help_gen_sample_size","text":"Compute sample sizes iteration","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_gen_sample_size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute sample sizes for each iteration — .help_gen_sample_size","text":"","code":".help_gen_sample_size(   n = NULL,   size = NULL,   prob = NULL,   method = \"poisson\",   iterations = 1,   ... )"},{"path":"https://songyosr.github.io/spax/reference/dot-help_gen_sample_size.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute sample sizes for each iteration — .help_gen_sample_size","text":"n Fixed sample size size Population size prob Probability parameter method Sampling method iterations Number iterations ... Additional arguments custom methods","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_gen_sample_size.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute sample sizes for each iteration — .help_gen_sample_size","text":"Vector sample sizes","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_prep_facilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Process facility supply and distance data for accessibility calculations — .help_prep_facilities","title":"Process facility supply and distance data for accessibility calculations — .help_prep_facilities","text":"Process facility supply distance data accessibility calculations","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_prep_facilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process facility supply and distance data for accessibility calculations — .help_prep_facilities","text":"","code":".help_prep_facilities(supply, distance_raster, names = NULL, snap = FALSE)"},{"path":"https://songyosr.github.io/spax/reference/dot-help_prep_facilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process facility supply and distance data for accessibility calculations — .help_prep_facilities","text":"supply Numeric vector facility capacities distance_raster Multi-layer SpatRaster distances facilities names Optional character vector facility names snap Logical; TRUE skip validation","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_prep_facilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process facility supply and distance data for accessibility calculations — .help_prep_facilities","text":"Named list validated processed components","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_process_supply.html","id":null,"dir":"Reference","previous_headings":"","what":"Process and validate supply data for accessibility calculations — .help_process_supply","title":"Process and validate supply data for accessibility calculations — .help_process_supply","text":"Process validate supply data accessibility calculations","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_process_supply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process and validate supply data for accessibility calculations — .help_process_supply","text":"","code":".help_process_supply(   supply,   id_col = NULL,   supply_cols = NULL,   weight_ids = NULL )"},{"path":"https://songyosr.github.io/spax/reference/dot-help_process_supply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process and validate supply data for accessibility calculations — .help_process_supply","text":"supply vector, matrix, data.frame containing supply capacity values id_col Character; column name facility IDs supply data.frame supply_cols Character vector; names supply columns supply data.frame weight_ids Character vector IDs weight layers matching","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_process_supply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process and validate supply data for accessibility calculations — .help_process_supply","text":"List containing: values Matrix vector supply values ids Vector facility IDs cols Names supply measures","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_transform_pmf_verify.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to verify PMF properties — .help_transform_pmf_verify","title":"Helper function to verify PMF properties — .help_transform_pmf_verify","text":"Helper function verify PMF properties","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_transform_pmf_verify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to verify PMF properties — .help_transform_pmf_verify","text":"","code":".help_transform_pmf_verify(pmf_raster)"},{"path":"https://songyosr.github.io/spax/reference/dot-help_transform_pmf_verify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to verify PMF properties — .help_transform_pmf_verify","text":"pmf_raster Computed PMF raster","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-help_transform_pmf_verify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to verify PMF properties — .help_transform_pmf_verify","text":"Invisible TRUE, warning precision issues detected","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-sample_pmf_core_evlv.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate evolving spatial samples across iterations — .sample_pmf_core_evlv","title":"Generate evolving spatial samples across iterations — .sample_pmf_core_evlv","text":"Generate evolving spatial samples across iterations","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-sample_pmf_core_evlv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate evolving spatial samples across iterations — .sample_pmf_core_evlv","text":"","code":".sample_pmf_core_evlv(   x,   n_samples,   iterations,   evolve_prop = 0.1,   replace_0 = TRUE,   snap = FALSE )"},{"path":"https://songyosr.github.io/spax/reference/dot-sample_pmf_core_indp.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate spatial samples — .sample_pmf_core_indp","title":"Generate spatial samples — .sample_pmf_core_indp","text":"Generate spatial samples","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-sample_pmf_core_indp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate spatial samples — .sample_pmf_core_indp","text":"","code":".sample_pmf_core_indp(x, n_samples, iterations, replace_0 = TRUE, snap = FALSE)"},{"path":"https://songyosr.github.io/spax/reference/dot-sample_pmf_core_indp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate spatial samples — .sample_pmf_core_indp","text":"x PMF raster n_samples Vector sample sizes iterations Number iterations replace_0 Logical NA replacement snap Logical snap mode","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-sample_pmf_core_indp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate spatial samples — .sample_pmf_core_indp","text":"Multi-layer SpatRaster samples","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-sample_pmf_internal.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal sampling function (moved from main body) — .sample_pmf_internal","title":"Internal sampling function (moved from main body) — .sample_pmf_internal","text":"Internal sampling function (moved main body)","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-sample_pmf_internal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal sampling function (moved from main body) — .sample_pmf_internal","text":"","code":".sample_pmf_internal(   x,   n,   size,   prob,   method,   iterations,   evolve_prop,   replace_0,   snap,   ... )"},{"path":"https://songyosr.github.io/spax/reference/dot-spread_core.html","id":null,"dir":"Reference","previous_headings":"","what":"Core spreading computation for single value vector — .spread_core","title":"Core spreading computation for single value vector — .spread_core","text":"Core spreading computation single value vector","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-spread_core.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Core spreading computation for single value vector — .spread_core","text":"","code":".spread_core(values, weights, full_output = FALSE)"},{"path":"https://songyosr.github.io/spax/reference/dot-spread_core.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Core spreading computation for single value vector — .spread_core","text":"values Numeric vector values weights Multi-layer SpatRaster weights full_output Whether return intermediate calculations","code":""},{"path":"https://songyosr.github.io/spax/reference/dot-spread_core.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Core spreading computation for single value vector — .spread_core","text":"SpatRaster list depending full_output","code":""},{"path":"https://songyosr.github.io/spax/reference/gather_demand.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate demand captured by each service site — gather_demand","title":"Calculate demand captured by each service site — gather_demand","text":"Specialized version gather_weighted() accessibility analysis. Calculates potential demand service site applying pre-computed spatial weights demand raster.","code":""},{"path":"https://songyosr.github.io/spax/reference/gather_demand.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate demand captured by each service site — gather_demand","text":"","code":"gather_demand(demand, weights)"},{"path":"https://songyosr.github.io/spax/reference/gather_demand.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate demand captured by each service site — gather_demand","text":"demand SpatRaster representing spatial distribution demand weights Multi-layer SpatRaster : - layer represents one service site - Values probability weights (0-1) distance decay - Layer names match site IDs","code":""},{"path":"https://songyosr.github.io/spax/reference/gather_demand.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate demand captured by each service site — gather_demand","text":"data.frame :         - location_id: identifier matching weight layer names         - potential_demand: weighted sum demand site","code":""},{"path":"https://songyosr.github.io/spax/reference/gather_demand.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate demand captured by each service site — gather_demand","text":"","code":"# Load example data - already lazy-loaded # u5pd # Under-5 population density raster # hos_iscr # Hospital isochrones  # Convert population to SpatRaster pop_terra <- terra::rast(u5pd)  # Calculate probability weights using gaussian decay weights <- calc_decay(   terra::rast(hos_iscr),   method = \"gaussian\",   sigma = 30 ) |>   calc_normalize(method = \"semi\") # Normalize to ensure proper probabilities  # Calculate potential demand for each hospital hospital_demands <- gather_demand(pop_terra, weights) head(hospital_demands) #>   location_id potential_demand #> 1        c172         7970.019 #> 2        c173         8244.629 #> 3        c174         4899.034 #> 4        c175         7579.809 #> 5        c176         6361.653 #> 6        c177         4527.153"},{"path":"https://songyosr.github.io/spax/reference/gather_weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate weighted values from a raster — gather_weighted","title":"Aggregate weighted values from a raster — gather_weighted","text":"General-purpose function aggregate values raster (single multi-layer) using stack weight rasters. layer weights represents different aggregation unit.","code":""},{"path":"https://songyosr.github.io/spax/reference/gather_weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate weighted values from a raster — gather_weighted","text":"","code":"gather_weighted(values, weights, na.rm = TRUE, simplify = FALSE, snap = FALSE)"},{"path":"https://songyosr.github.io/spax/reference/gather_weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate weighted values from a raster — gather_weighted","text":"values SpatRaster representing values aggregated. Can single multi-layer. multi-layer, layer represents different realization/scenario. weights Multi-layer SpatRaster : - layer represents one aggregation unit - Values weights (typically 0-1) aggregation - Layer names match unit IDs na.rm Logical; TRUE, remove NA values computation (default = TRUE) simplify Logical; TRUE, returns vector (single layer) matrix (multi-layer). FALSE, returns data.frame wide format. (default = FALSE) snap Logical; TRUE, avoid input validation formatting. Used performance optimization internal functions.","code":""},{"path":"https://songyosr.github.io/spax/reference/gather_weighted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate weighted values from a raster — gather_weighted","text":"Depending input simplify parameter:         - simplify=TRUE single layer: named vector         - simplify=TRUE multi-layer: matrix rownames=units, colnames=scenarios         - simplify=FALSE: data.frame wide format unit_id column","code":""},{"path":"https://songyosr.github.io/spax/reference/gather_weighted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate weighted values from a raster — gather_weighted","text":"","code":"# Load necessary library library(terra)  # Create test data values <- rast(matrix(1:9, 3, 3)) # Single layer weights <- c(   rast(matrix(runif(9), 3, 3)),   rast(matrix(runif(9), 3, 3)) ) names(weights) <- c(\"unit1\", \"unit2\")  # Single layer example result1 <- gather_weighted(values, weights, simplify = TRUE) result1_df <- gather_weighted(values, weights)  # Multi-layer example values_multi <- c(values, values * 2) # Two scenarios names(values_multi) <- c(\"sim1\", \"sim2\") result2 <- gather_weighted(values_multi, weights, simplify = TRUE) # Returns matrix result2_df <- gather_weighted(values_multi, weights)"},{"path":"https://songyosr.github.io/spax/reference/hc12.html","id":null,"dir":"Reference","previous_headings":"","what":"Health Facilities in Thailand's Region 12 — hc12","title":"Health Facilities in Thailand's Region 12 — hc12","text":"collection spatial datasets containing information health facilities Thailand's Region 12 (Southern Border Provinces) year 2020 (B.E. 2563). data split two complementary datasets: primary health centers (PHC) hospitals.","code":""},{"path":"https://songyosr.github.io/spax/reference/hc12.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Health Facilities in Thailand's Region 12 — hc12","text":"datasets sf objects point geometry (UTM zone 47N, EPSG:32647) containing following variables: id Unique identifier facility (unordered!) hoslvl Factor indicating facility level:         \"1-Community\", \"2-General\", \"3-Regional\" bed Number hospital beds s_doc Number doctors s_dent Number dentists s_nurse Number nurses s_hv Number health volunteers d_pop_moph Total population service area d_pop_moph_60 Population aged 60 service area d_pop_moph_05 Population aged 0-5 service area geometry Point geometry representing facility location","code":""},{"path":"https://songyosr.github.io/spax/reference/hc12.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Health Facilities in Thailand's Region 12 — hc12","text":"Office Permanent Secretary, Ministry Public Health. (2020). Government Open Data Services. Retrieved December 19, 2024, https://opendata.moph.go.th dataset combines three main data sources MoPH API: Facility locations characteristics (GIS service) Healthcare provider statistics Population service area statistics","code":""},{"path":"https://songyosr.github.io/spax/reference/hc12.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Health Facilities in Thailand's Region 12 — hc12","text":"data split two datasets: hc12_phc: Primary Health Centers (n=819) facilities level \"1-Community\" inpatient beds (bed = 0) Typically staffed 1-4 healthcare providers Strong health volunteer presence (s_hv > 0) Serves defined population catchments hc12_hos: Hospitals (n=77) Includes general (level 2) regional hospitals (level 3) inpatient beds (30-591 beds) Larger healthcare workforce Limited health volunteer involvement Population data available facility level","code":""},{"path":"https://songyosr.github.io/spax/reference/hc12.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Health Facilities in Thailand's Region 12 — hc12","text":"Variables prefixed indicate type: 's_': Supply indicators (healthcare workforce) 'd_': Demand indicators (population statistics)","code":""},{"path":"https://songyosr.github.io/spax/reference/hc12.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Health Facilities in Thailand's Region 12 — hc12","text":"","code":"if (FALSE) { # \\dontrun{ # Load the datasets data(hc12_phc) data(hc12_hos)  # Compare facility distributions table(hc12_hos$hoslvl)  # Summary of healthcare workforce summary(hc12_phc[c(\"s_doc\", \"s_nurse\", \"s_hv\")]) summary(hc12_hos[c(\"s_doc\", \"s_nurse\", \"s_hv\")])  # Plot facilities by type library(ggplot2) ggplot() +   geom_sf(data = hc12_phc, aes(color = \"PHC\")) +   geom_sf(data = hc12_hos, aes(color = \"Hospital\")) +   scale_color_manual(values = c(\"PHC\" = \"blue\", \"Hospital\" = \"red\")) +   theme_minimal() } # }"},{"path":"https://songyosr.github.io/spax/reference/hos_iscr.html","id":null,"dir":"Reference","previous_headings":"","what":"Hospital Travel Time Isochrones (Raster Format) — hos_iscr","title":"Hospital Travel Time Isochrones (Raster Format) — hos_iscr","text":"RasterStack containing travel time isochrones 77 hospitals Thailand's Region 12. layer represents travel time (minutes) reach one hospital, computed using OSRM (Open Source Routing Machine) routing engine.","code":""},{"path":"https://songyosr.github.io/spax/reference/hos_iscr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hospital Travel Time Isochrones (Raster Format) — hos_iscr","text":"","code":"hos_iscr"},{"path":"https://songyosr.github.io/spax/reference/hos_iscr.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Hospital Travel Time Isochrones (Raster Format) — hos_iscr","text":"RasterStack 77 layers following specifications: Dimensions 509 rows × 647 columns × 77 layers Resolution 520.4038 × 520.4038 meters Extent 505646.5, 842347.8, 620843.7, 885729.2 (xmin, xmax, ymin, ymax) CRS WGS 84 / UTM zone 47N (EPSG:32647) Values Travel time minutes Layer Names Match facility IDs hc12_hos (e.g., \"c172\", \"c173\")","code":""},{"path":"https://songyosr.github.io/spax/reference/hos_iscr.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Hospital Travel Time Isochrones (Raster Format) — hos_iscr","text":"Computed using OSRM (Open Source Routing Machine) OpenStreetMap data. Hospital locations hc12_hos.","code":""},{"path":"https://songyosr.github.io/spax/reference/hos_iscr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hospital Travel Time Isochrones (Raster Format) — hos_iscr","text":"Travel times calculated using following time-break structure: 1-minute intervals first 10 minutes 2-minute intervals 12 30 minutes 5-minute intervals 35 60 minutes 15-minute intervals 75 180 minutes isochrones generated using hospital locations hc12_hos.","code":""},{"path":"https://songyosr.github.io/spax/reference/hos_iscr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hospital Travel Time Isochrones (Raster Format) — hos_iscr","text":"Luxen, D., & Vetter, C. (2011). Real-time routing OpenStreetMap data. Proceedings 19th ACM SIGSPATIAL International Conference Advances Geographic Information Systems (pp. 513-516).","code":""},{"path":"https://songyosr.github.io/spax/reference/hos_iscvec.html","id":null,"dir":"Reference","previous_headings":"","what":"Hospital Travel Time Isochrones (Vector Format) — hos_iscvec","title":"Hospital Travel Time Isochrones (Vector Format) — hos_iscvec","text":"spatial dataset containing travel time isochrone polygons 77 hospitals Thailand's Region 12. vector format provides original isochrone bands hos_iscr derived.","code":""},{"path":"https://songyosr.github.io/spax/reference/hos_iscvec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hospital Travel Time Isochrones (Vector Format) — hos_iscvec","text":"","code":"hos_iscvec"},{"path":"https://songyosr.github.io/spax/reference/hos_iscvec.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Hospital Travel Time Isochrones (Vector Format) — hos_iscvec","text":"sf object 2027 features 5 fields: id Numeric ID isochrone band isomin Minimum travel time minutes band isomax Maximum travel time minutes band location_id Hospital identifier matching hc12_hos iso_mean Mean travel time band ((isomin + isomax)/2) geometry MULTIPOLYGON geometry UTM zone 47N","code":""},{"path":"https://songyosr.github.io/spax/reference/hos_iscvec.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Hospital Travel Time Isochrones (Vector Format) — hos_iscvec","text":"Computed using OSRM OpenStreetMap data. Hospital locations hc12_hos.","code":""},{"path":"https://songyosr.github.io/spax/reference/hos_iscvec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hospital Travel Time Isochrones (Vector Format) — hos_iscvec","text":"vector dataset provided demonstrate isochrone generation process conversion raster format. raster version (hos_iscr) recommended accessibility analysis within spax package.","code":""},{"path":"https://songyosr.github.io/spax/reference/hos_iscvec.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hospital Travel Time Isochrones (Vector Format) — hos_iscvec","text":"Luxen, D., & Vetter, C. (2011). Real-time routing OpenStreetMap data. Proceedings 19th ACM SIGSPATIAL International Conference Advances Geographic Information Systems (pp. 513-516).","code":""},{"path":"https://songyosr.github.io/spax/reference/load_phc_iscr.html","id":null,"dir":"Reference","previous_headings":"","what":"Primary Health Center Travel Time Isochrones — load_phc_iscr","title":"Primary Health Center Travel Time Isochrones — load_phc_iscr","text":"Load Primary Health Center (PHC) isochrone data stored external data. data represents travel time isochrones 819 PHCs Thailand's Region 12, limited 60-minute travel time reflect local service areas.","code":""},{"path":"https://songyosr.github.io/spax/reference/load_phc_iscr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primary Health Center Travel Time Isochrones — load_phc_iscr","text":"","code":"load_phc_iscr()"},{"path":"https://songyosr.github.io/spax/reference/load_phc_iscr.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Primary Health Center Travel Time Isochrones — load_phc_iscr","text":"returned SpatRaster following specifications: Dimensions 509 rows × 647 columns × 819 layers Resolution 520.4038 × 520.4038 meters Extent 505646.5, 842347.8, 620843.7, 885729.2 (xmin, xmax, ymin, ymax) CRS WGS 84 / UTM zone 47N (EPSG:32647) Values Travel time minutes (limited 60 minutes) Layer Names Match facility IDs hc12_phc (e.g., \"c001\", \"c002\")","code":""},{"path":"https://songyosr.github.io/spax/reference/load_phc_iscr.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Primary Health Center Travel Time Isochrones — load_phc_iscr","text":"Travel times computed using OSRM OpenStreetMap data (2024). PHC locations Thailand's Ministry Public Health (2020).","code":""},{"path":"https://songyosr.github.io/spax/reference/load_phc_iscr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primary Health Center Travel Time Isochrones — load_phc_iscr","text":"SpatRaster object containing PHC isochrones","code":""},{"path":"https://songyosr.github.io/spax/reference/load_phc_iscr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Primary Health Center Travel Time Isochrones — load_phc_iscr","text":"Travel times calculated using following time-break structure optimized local service areas: 1-minute intervals first 10 minutes 2-minute intervals 12 30 minutes 5-minute intervals 35 60 minutes 60-minute limit reflects local service nature PHCs optimizes computational efficiency.","code":""},{"path":"https://songyosr.github.io/spax/reference/load_phc_iscr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Primary Health Center Travel Time Isochrones — load_phc_iscr","text":"Luxen, D., & Vetter, C. (2011). Real-time routing OpenStreetMap data.     Proceedings 19th ACM SIGSPATIAL International Conference     Advances Geographic Information Systems (pp. 513-516). Office Permanent Secretary, Ministry Public Health. (2020).     Government Open Data Services.","code":""},{"path":[]},{"path":"https://songyosr.github.io/spax/reference/load_phc_iscr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Primary Health Center Travel Time Isochrones — load_phc_iscr","text":"","code":"if (FALSE) { # \\dontrun{ # Load PHC isochrones phc_isochrones <- load_phc_iscr()  # Plot first layer plot(phc_isochrones[[1]],      main = \"Travel Time to First PHC\") } # }"},{"path":"https://songyosr.github.io/spax/reference/sample_pmf.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample Points from Probability Surface with Multiple Realizations — sample_pmf","title":"Sample Points from Probability Surface with Multiple Realizations — sample_pmf","text":"Generates multiple realizations point patterns probability mass function (PMF) surface using vectorized approach. function supports deterministic sampling fixed sample sizes probabilistic sampling based population parameters.","code":""},{"path":"https://songyosr.github.io/spax/reference/sample_pmf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample Points from Probability Surface with Multiple Realizations — sample_pmf","text":"","code":"sample_pmf(   x,   n = NULL,   size = NULL,   prob = NULL,   method = \"poisson\",   iterations = 1,   evolve_prop = 1,   seed = NULL,   replace_0 = TRUE,   snap = FALSE,   ... )"},{"path":"https://songyosr.github.io/spax/reference/sample_pmf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample Points from Probability Surface with Multiple Realizations — sample_pmf","text":"x SpatRaster representing spatial distribution. Can either: - PMF values sum 1 - Raw density values converted PMF (except snap mode) n Integer NULL. Fixed number samples deterministic sampling. specified, overrides probabilistic sampling parameters. size Integer NULL. Population size parameter probability distributions. NULL input density (PMF), calculated data. prob Numeric 0 1. Probability parameter sampling methods (e.g., disease prevalence, detection probability). method Character string function specifying sampling method: - \"poisson\": Random size mean = size * prob - \"binomial\": Random size binomial(size, prob) - \"nbinom\": Random size negative binomial(size, prob) - custom function: Must return vector length 'iterations' iterations Integer. Number realizations generate (default = 1) evolve_prop Numeric 0 1. Controls sample evolution iterations: - 1 (default): Independent sampling, new samples iteration - 0: new samples, returns first iteration - (0,1): Proportion samples evolve iteration seed Integer NULL. Random seed reproducibility replace_0 Logical. TRUE, replaces zero values NA (default = TRUE) snap Logical. TRUE, enters fast mode minimal validation (default = FALSE) ... Additional arguments passed custom sampling function","code":""},{"path":"https://songyosr.github.io/spax/reference/sample_pmf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample Points from Probability Surface with Multiple Realizations — sample_pmf","text":"SpatRaster one layer per realization (single layer evolve_prop = 0),         containing counts samples per cell. replace_0 = TRUE, cells zero         counts contain NA.","code":""},{"path":"https://songyosr.github.io/spax/reference/sample_pmf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample Points from Probability Surface with Multiple Realizations — sample_pmf","text":"","code":"if (FALSE) { # \\dontrun{ # Create sample population density r <- terra::rast(nrows = 10, ncols = 10) terra::values(r) <- runif(100) * 100  # Example 1: Independent sampling (default) samples1 <- sample_pmf(r, n = 50, iterations = 5)  # Example 2: Evolving samples samples2 <- sample_pmf(r,   n = 50,   iterations = 5,   evolve_prop = 0.3 # 30% new samples each iteration )  # Example 3: Disease case simulation with evolution samples3 <- sample_pmf(r,   size = 10000, # population size   prob = 0.001, # disease prevalence   method = \"poisson\",   iterations = 100,   evolve_prop = 0.2 ) } # }"},{"path":"https://songyosr.github.io/spax/reference/spax-package.html","id":null,"dir":"Reference","previous_headings":"","what":"spax: Modular Raster-Based Spatial Accessibility Analysis — spax-package","title":"spax: Modular Raster-Based Spatial Accessibility Analysis — spax-package","text":"fresh take spatial accessibility analysis combines modular design raster-based computation. Like LEGO bricks spatial analysis, package provides building blocks family two-step floating catchment area (2SFCA) analysis can mix match. Built around continuous surfaces rather discrete points, 'spax' makes easy work high-resolution population data complex service areas. Features include flexible distance decay functions, Monte Carlo simulation uncertainty analysis, support multiple supply indicators. Whether planning healthcare services analyzing coffee shop coverage, 'spax' helps build analysis need.","code":""},{"path":[]},{"path":"https://songyosr.github.io/spax/reference/spax-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"spax: Modular Raster-Based Spatial Accessibility Analysis — spax-package","text":"Maintainer: Songyos Rajborirug songyos.r@psu.ac.th (ORCID)","code":""},{"path":"https://songyosr.github.io/spax/reference/spax_2sfca.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Original Two-Step Floating Catchment Area (2SFCA) accessibility scores — spax_2sfca","title":"Calculate Original Two-Step Floating Catchment Area (2SFCA) accessibility scores — spax_2sfca","text":"Implements original Two-Step Floating Catchment Area (2SFCA) method using binary catchment areas, proposed Luo & Wang (2003). foundational method uses single distance/time threshold define service areas computes accessibility ratio supply demand within catchments.","code":""},{"path":"https://songyosr.github.io/spax/reference/spax_2sfca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Original Two-Step Floating Catchment Area (2SFCA) accessibility scores — spax_2sfca","text":"","code":"spax_2sfca(   demand,   supply,   distance,   threshold,   id_col = NULL,   supply_cols = NULL,   snap = FALSE )"},{"path":"https://songyosr.github.io/spax/reference/spax_2sfca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Original Two-Step Floating Catchment Area (2SFCA) accessibility scores — spax_2sfca","text":"demand SpatRaster representing spatial distribution demand supply vector, matrix, data.frame containing supply capacity values distance SpatRaster stack travel times/distances facilities threshold Numeric value defining catchment area cutoff (units distance) id_col Character; column name facility IDs supply data.frame supply_cols Character vector; names supply columns supply data.frame snap Logical; TRUE enable fast computation mode (default = FALSE)","code":""},{"path":"https://songyosr.github.io/spax/reference/spax_2sfca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Original Two-Step Floating Catchment Area (2SFCA) accessibility scores — spax_2sfca","text":"SpatRaster accessibility scores","code":""},{"path":"https://songyosr.github.io/spax/reference/spax_2sfca.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Original Two-Step Floating Catchment Area (2SFCA) accessibility scores — spax_2sfca","text":"original Two-Step Floating Catchment Area (2SFCA) method operates two steps: Step 1: facility j: * Define catchment area within threshold distance/time * Sum population demand locations within catchment * Calculate supply--demand ratio Rj = Sj/sum(Pi) Step 2: demand location : * Define catchment area within threshold distance/time * Sum facility ratios Rj within catchment * Final accessibility score Ai = sum(Rj) Key characteristics: 1. Binary catchment areas (within threshold = 1, beyond = 0) 2. Equal weights locations within catchment 3. normalization demand weights 4. Single threshold value steps Limitations addressed later methods: * distance decay within catchments * Artificial barriers catchment boundaries * Potential demand overestimation overlapping areas","code":""},{"path":"https://songyosr.github.io/spax/reference/spax_2sfca.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Original Two-Step Floating Catchment Area (2SFCA) accessibility scores — spax_2sfca","text":"Luo, W., & Wang, F. (2003). Measures Spatial Accessibility Health Care GIS Environment: Synthesis Case Study Chicago Region. *Environment Planning B: Planning Design*, *30*(6), 865-884. https://doi.org/10.1068/b29120","code":""},{"path":[]},{"path":"https://songyosr.github.io/spax/reference/spax_2sfca.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Original Two-Step Floating Catchment Area (2SFCA) accessibility scores — spax_2sfca","text":"","code":"# Load example data library(terra) library(sf) #> Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE  # Convert under-5 population density to proper format pop_rast <- rast(u5pd)  # Drop geometry for supply data hc12_hos <- hc12_hos |> st_drop_geometry()  # Calculate accessibility to doctors with 30-minute catchment result <- spax_2sfca(   demand = pop_rast,   supply = hc12_hos,   distance = rast(hos_iscr),   threshold = 30, # 30-minute catchment   id_col = \"id\",   supply_cols = \"s_doc\" )  # Plot the results plot(result, main = \"Doctor Accessibility (Original 2SFCA)\")   # Calculate accessibility to multiple supply types result_multi <- spax_2sfca(   demand = pop_rast,   supply = hc12_hos,   distance = rast(hos_iscr),   threshold = 30,   id_col = \"id\",   supply_cols = c(\"s_doc\", \"s_nurse\") )  # Plot both doctor and nurse accessibility plot(result_multi)"},{"path":"https://songyosr.github.io/spax/reference/spax_e2sfca.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Enhanced Two-Step Floating Catchment Area (E2SFCA) accessibility scores — spax_e2sfca","title":"Calculate Enhanced Two-Step Floating Catchment Area (E2SFCA) accessibility scores — spax_e2sfca","text":"Implements Enhanced Two-Step Floating Catchment Area (E2SFCA) method proposed Luo & Qi (2009). method improves upon original 2SFCA incorporating distance decay effects allowing variable catchment sizes, providing realistic measures spatial accessibility services.","code":""},{"path":"https://songyosr.github.io/spax/reference/spax_e2sfca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Enhanced Two-Step Floating Catchment Area (E2SFCA) accessibility scores — spax_e2sfca","text":"","code":"spax_e2sfca(   demand,   supply,   distance,   decay_params = list(method = \"gaussian\", sigma = 30),   demand_normalize = \"identity\",   id_col = NULL,   supply_cols = NULL,   indicator_names = NULL,   snap = FALSE )"},{"path":"https://songyosr.github.io/spax/reference/spax_e2sfca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Enhanced Two-Step Floating Catchment Area (E2SFCA) accessibility scores — spax_e2sfca","text":"demand SpatRaster representing spatial distribution demand supply vector, matrix, data.frame containing supply capacity values distance SpatRaster stack travel times/distances facilities decay_params List parameters decay function: method: \"gaussian\", \"exponential\", \"power\", \"binary\" sigma: decay parameter controlling rate distance decay Additional parameters passed custom decay functions demand_normalize Character specifying normalization method: \"identity\": normalization (original weights) \"standard\": Weights sum 1 (prevents demand inflation) \"semi\": Normalize sum > 1 (prevents deflation) id_col Character; column name facility IDs supply data.frame supply_cols Character vector; names supply columns supply data.frame indicator_names Character vector; custom names output accessibility layers snap Logical; TRUE enable fast computation mode (default = FALSE)","code":""},{"path":"https://songyosr.github.io/spax/reference/spax_e2sfca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Enhanced Two-Step Floating Catchment Area (E2SFCA) accessibility scores — spax_e2sfca","text":"SpatRaster accessibility scores","code":""},{"path":"https://songyosr.github.io/spax/reference/spax_e2sfca.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Enhanced Two-Step Floating Catchment Area (E2SFCA) accessibility scores — spax_e2sfca","text":"E2SFCA method enhances original 2SFCA introducing: Step 1: facility j: * Weight demand points distance decay: Wd(dij) * Calculate supply--demand ratio Rj = Sj/sum(Pi * Wd(dij)) Step 2: demand location : * Weight facility ratios distance decay: Wr(dij) * Calculate accessibility score Ai = sum(Rj * Wr(dij)) Key improvements original 2SFCA: 1. Distance decay within catchments 2. Differentiated travel behavior demand vs. access phases 3. Smoother accessibility surfaces 4. realistic representation access barriers method supports various distance decay functions normalization approaches handle different accessibility scenarios prevent demand overestimation overlapping service areas.","code":""},{"path":"https://songyosr.github.io/spax/reference/spax_e2sfca.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Enhanced Two-Step Floating Catchment Area (E2SFCA) accessibility scores — spax_e2sfca","text":"Luo, W., & Qi, Y. (2009). enhanced two-step floating catchment area (E2SFCA) method measuring spatial accessibility primary care physicians. *Health & Place*, *15*(4), 1100-1107. https://doi.org/10.1016/j.healthplace.2009.06.002","code":""},{"path":[]},{"path":"https://songyosr.github.io/spax/reference/spax_e2sfca.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Enhanced Two-Step Floating Catchment Area (E2SFCA) accessibility scores — spax_e2sfca","text":"","code":"# Load example data library(terra) library(sf)  # Convert under-5 population density to proper format pop_rast <- rast(u5pd)  # Drop geometry for supply data hc12_hos <- hc12_hos |> st_drop_geometry()  # Calculate accessibility with Gaussian decay result <- spax_e2sfca(   demand = pop_rast,   supply = hc12_hos,   distance = rast(hos_iscr),   decay_params = list(     method = \"gaussian\",     sigma = 30 # 30-minute characteristic distance   ),   demand_normalize = \"semi\", # Prevent demand inflation   id_col = \"id\",   supply_cols = \"s_doc\" )  # Plot the results plot(result, main = \"Doctor Accessibility (E2SFCA)\")   # Compare different decay functions result_exp <- spax_e2sfca(   demand = pop_rast,   supply = hc12_hos,   distance = rast(hos_iscr),   decay_params = list(     method = \"exponential\",     sigma = 0.1   ),   demand_normalize = \"semi\",   id_col = \"id\",   supply_cols = \"s_doc\" )  # Plot both for comparison plot(c(result, result_exp),   main = c(\"Gaussian Decay\", \"Exponential Decay\") )"},{"path":"https://songyosr.github.io/spax/reference/spax_ifca.html","id":null,"dir":"Reference","previous_headings":"","what":"Iterative Floating Catchment Area (iFCA) Analysis — spax_ifca","title":"Iterative Floating Catchment Area (iFCA) Analysis — spax_ifca","text":"Computes spatial accessibility scores using iterative floating catchment area method combines Huff-model based choice probabilities distance decay effects. enhanced version supports time-series demand patterns customizable decay functions. iFCA method extends traditional FCA approaches : Supporting dynamic demand patterns multi-layer inputs Incorporating flexible distance decay specifications Iteratively balancing supply demand Using learning rate control convergence","code":""},{"path":"https://songyosr.github.io/spax/reference/spax_ifca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Iterative Floating Catchment Area (iFCA) Analysis — spax_ifca","text":"","code":"spax_ifca(   distance_raster,   demand,   supply,   decay_params = list(method = \"gaussian\", sigma = 30),   lambda = 0.5,   max_iter = 100,   tolerance = 1e-06,   window_size = 5,   convergence_type = c(\"utilization\", \"ratio\"),   snap = FALSE,   debug = FALSE )"},{"path":"https://songyosr.github.io/spax/reference/spax_ifca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Iterative Floating Catchment Area (iFCA) Analysis — spax_ifca","text":"distance_raster multi-layer SpatRaster layer represents distances one facility. layers must share extent resolution. demand SpatRaster demand distribution. Can either: - Single layer static demand - Multiple layers (matching max_iter) dynamic demand supply Numeric vector facility capacities. Length must match number layers distance_raster. decay_params List parameters decay function: method: \"gaussian\", \"exponential\", \"power\", custom function sigma: decay parameter controlling spatial interaction strength Additional parameters passed custom decay functions lambda Learning rate 0 1 controlling convergence speed. Lower values provide stability slower convergence. Default: 0.5 max_iter Maximum number iterations attempt. multi-layer demand, must match number demand layers. Default: 100 tolerance Convergence tolerance threshold. Iteration stops rolling average differences falls value. Default: 1e-6 window_size Size rolling window convergence checking. Default: 5 convergence_type Character string specifying convergence metric, one : \"utilization\" (default) \"ratio\" snap Logical; TRUE enables fast computation mode returning utilization vector. Default: FALSE debug Logical; TRUE provides detailed convergence information. Default: FALSE","code":""},{"path":"https://songyosr.github.io/spax/reference/spax_ifca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Iterative Floating Catchment Area (iFCA) Analysis — spax_ifca","text":"snap = TRUE:   Numeric vector predicted utilization facilities snap = FALSE:   list containing: utilization Numeric vector predicted facility utilization ratios Numeric vector final supply-demand ratios attractiveness Numeric vector final facility attractiveness values accessibility SpatRaster accessibility scores convergence List convergence details: iterations: Number iterations run converged: Logical indicating convergence achieved type: Convergence check method used final_average: Final rolling average differences window_size: Size rolling window used  history Array historical state values converged, NULL otherwise parameters List parameter values used computation","code":""},{"path":[]},{"path":"https://songyosr.github.io/spax/reference/spax_ifca.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Iterative Floating Catchment Area (iFCA) Analysis — spax_ifca","text":"","code":"if (FALSE) { # \\dontrun{ # Basic usage with static demand result <- spax_ifca(   distance_raster = dist_rast,   demand = pop_rast,   supply = facility_capacity,   decay_params = list(     method = \"gaussian\",     sigma = 30   ) )  # Using custom decay function custom_decay <- function(distance, sigma = 30, threshold = 60) {   weights <- exp(-distance^2 / (2 * sigma^2))   weights[distance > threshold] <- 0   return(weights) }  result <- spax_ifca(   distance_raster = dist_rast,   demand = pop_rast,   supply = facility_capacity,   decay_params = list(     method = custom_decay,     sigma = 30,     threshold = 60   ) )  # With time-series demand (must match max_iter) result <- spax_ifca(   distance_raster = dist_rast,   demand = demand_series,  # Multi-layer demand   supply = facility_capacity,   max_iter = nlyr(demand_series),   decay_params = list(method = \"gaussian\", sigma = 30) ) } # }"},{"path":"https://songyosr.github.io/spax/reference/spread_weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Distribute values across weighted surfaces — spread_weighted","title":"Distribute values across weighted surfaces — spread_weighted","text":"General-purpose function distribute values across space using stack weight rasters. input value spread according corresponding weight layer.","code":""},{"path":"https://songyosr.github.io/spax/reference/spread_weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distribute values across weighted surfaces — spread_weighted","text":"","code":"spread_weighted(   values,   weights,   value_cols = NULL,   full_output = FALSE,   name_prefix = NULL,   snap = FALSE )"},{"path":"https://songyosr.github.io/spax/reference/spread_weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distribute values across weighted surfaces — spread_weighted","text":"values Numeric vector, matrix, data.frame values distribute: - Vector: Must match number weight layers - Matrix: Rows match weight layers, columns different measures - Data.frame: matrix requires value_cols parameter weights Multi-layer SpatRaster layer represents one unit's weighted distribution surface value_cols Character vector column names values data.frame full_output Logical; whether return intermediate calculations (default FALSE) name_prefix Character string prepend output names (default NULL) snap Logical; TRUE, avoid input validation performance (default FALSE)","code":""},{"path":"https://songyosr.github.io/spax/reference/spread_weighted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distribute values across weighted surfaces — spread_weighted","text":"full_output = TRUE, returns list containing:         - total_distribution: SpatRaster stack total distribution per measure         - unit_distribution: List unit-specific distribution SpatRasters         full_output = FALSE, returns total_distribution SpatRaster","code":""},{"path":"https://songyosr.github.io/spax/reference/spread_weighted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distribute values across weighted surfaces — spread_weighted","text":"","code":"if (FALSE) { # \\dontrun{ # Example 1: Basic vector input using package data # Spread doctor counts across space using distance-decay weights weights <- calc_decay(hos_iscr, method = \"gaussian\", sigma = 30) doc_distribution <- spread_weighted(hc12_hos$s_doc, weights)  # Example 2: Multiple supply measures supply_df <- hc12_hos[c(\"s_doc\", \"s_nurse\")] distributions <- spread_weighted(supply_df, weights,   value_cols = c(\"s_doc\", \"s_nurse\"),   parallel = TRUE )  # Example 3: With full output for detailed analysis result <- spread_weighted(hc12_hos$s_doc, weights,   full_output = TRUE ) plot(result$total_distribution, main = \"Total Distribution\") plot(result$unit_distribution[[1]], main = \"First Unit Distribution\") } # }"},{"path":"https://songyosr.github.io/spax/reference/transform_pmf.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Probability Mass Function from Population Density — transform_pmf","title":"Compute Probability Mass Function from Population Density — transform_pmf","text":"Converts population density raster probability mass function (PMF) cell values sum 1. Useful spatial sampling probability selection proportional population density.","code":""},{"path":"https://songyosr.github.io/spax/reference/transform_pmf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Probability Mass Function from Population Density — transform_pmf","text":"","code":"transform_pmf(x, return_total = FALSE, snap = FALSE)"},{"path":"https://songyosr.github.io/spax/reference/transform_pmf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Probability Mass Function from Population Density — transform_pmf","text":"x SpatRaster density values (e.g., population density) return_total logical; TRUE, returns list containing PMF raster total population. FALSE (default), returns PMF raster snap Logical; TRUE skip validation verification","code":""},{"path":"https://songyosr.github.io/spax/reference/transform_pmf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Probability Mass Function from Population Density — transform_pmf","text":"return_total = FALSE, returns SpatRaster containing probability values         sum 1. return_total = TRUE, returns list components: pmf: SpatRaster probability values total: numeric value total density","code":""},{"path":"https://songyosr.github.io/spax/reference/transform_pmf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Probability Mass Function from Population Density — transform_pmf","text":"","code":"# Basic usage pop_density <- terra::rast(matrix(1:100, 10, 10)) pmf <- transform_pmf(pop_density)  # Get PMF and total population result <- transform_pmf(pop_density, return_total = TRUE) pmf <- result$pmf total_pop <- result$total"},{"path":"https://songyosr.github.io/spax/reference/u5pd.html","id":null,"dir":"Reference","previous_headings":"","what":"Under-5 Population Density in Thailand's Health Region 12 — u5pd","title":"Under-5 Population Density in Thailand's Health Region 12 — u5pd","text":"RasterLayer object containing population density estimates children five years old Thailand's Health Region 12. data represents number children per grid cell, derived Meta's High Resolution Population Density Maps project.","code":""},{"path":"https://songyosr.github.io/spax/reference/u5pd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Under-5 Population Density in Thailand's Health Region 12 — u5pd","text":"","code":"u5pd"},{"path":"https://songyosr.github.io/spax/reference/u5pd.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Under-5 Population Density in Thailand's Health Region 12 — u5pd","text":"raster object following specifications: Dimensions 865 rows × 1100 columns Resolution 520.4038 × 520.4038 meters Extent 505677.7, 842408.5, 620846.3, 885639.2 (xmin, xmax, ymin, ymax) CRS WGS 84 / UTM zone 47N (EPSG:32647) Values Population density (children per grid cell) Range Minimum: 0, Maximum: 33.19188","code":""},{"path":"https://songyosr.github.io/spax/reference/u5pd.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Under-5 Population Density in Thailand's Health Region 12 — u5pd","text":"Meta. (2024). High Resolution Population Density Maps. Data Good Meta. Retrieved https://dataforgood.facebook.com/dfg/tools/high-resolution-population-density-maps","code":""},{"path":"https://songyosr.github.io/spax/reference/u5pd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Under-5 Population Density in Thailand's Health Region 12 — u5pd","text":"dataset processed Meta's High Resolution Population Density Maps Thailand (2020). original data aggregated 520.4038-meter resolution balance spatial detail computational efficiency. Zero values indicate areas estimated child population, NA values represent areas outside region boundary without data coverage. data stored RasterLayer object can easily converted SpatRaster using terra::rast() use spax package functions.","code":""},{"path":"https://songyosr.github.io/spax/reference/u5pd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Under-5 Population Density in Thailand's Health Region 12 — u5pd","text":"","code":"if (FALSE) { # \\dontrun{ # Convert to SpatRaster for use with spax u5pd_terra <- terra::rast(u5pd)  # Basic visualization plot(u5pd_terra, main = \"Under-5 Population Density\")  # Get basic statistics terra::global(u5pd_terra, \"sum\", na.rm = TRUE) # Total estimated children terra::global(u5pd_terra, c(\"min\", \"max\"), na.rm = TRUE) # Range of density values  # Convert to probability mass function for spatial sampling pmf_result <- transform_pmf(u5pd_terra, return_total = TRUE) pop_pmf <- pmf_result$pmf total_pop <- pmf_result$total  # Generate sample points based on density samples <- sample_pmf(   pop_pmf,   method = \"poisson\",   size = total_pop,   prob = 0.1, # Example sampling rate   iterations = 1 ) } # }"}]
